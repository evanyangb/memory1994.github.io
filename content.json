{"meta":{"title":"EvanYang's Blog","subtitle":null,"description":null,"author":"Evan Yang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:33:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章标记","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:33:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"css基础","slug":"面试-css","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:36:08.000Z","comments":true,"path":"2019/05/13/面试-css/","link":"","permalink":"http://yoursite.com/2019/05/13/面试-css/","excerpt":"","text":"","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"css面试题","slug":"css面试题","permalink":"http://yoursite.com/tags/css面试题/"}]},{"title":"markdowm使用文档","slug":"markdowm文档","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-14T06:36:29.000Z","comments":true,"path":"2019/05/11/markdowm文档/","link":"","permalink":"http://yoursite.com/2019/05/11/markdowm文档/","excerpt":"","text":"欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter文档管理 Cmd + O系统菜单 Cmd + M 加粗 Cmd + B插入图片 Cmd + G插入链接 Cmd + L提升标题 Cmd + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#117;&#115;&#x74;&#x67;&#x6f;&#x63;&#x6b;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[{"name":"文档使用","slug":"文档使用","permalink":"http://yoursite.com/categories/文档使用/"}],"tags":[{"name":"markdowm","slug":"markdowm","permalink":"http://yoursite.com/tags/markdowm/"}]},{"title":"web安全类","slug":"面试-web安全","date":"2018-04-29T16:00:00.000Z","updated":"2019-05-15T10:15:03.000Z","comments":true,"path":"2018/04/30/面试-web安全/","link":"","permalink":"http://yoursite.com/2018/04/30/面试-web安全/","excerpt":"","text":"XSS攻击XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。 XSS分类 根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击： 反射型XSS当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。 反射型XSS的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 如何防范反射型XSS攻击 对字符串进行编码。 对url的查询参数进行转义后再输出到页面。 1234app.get('/welcome', function(req, res) &#123; //对查询参数进行编码，避免反射型 XSS攻击 res.send(`$&#123;encodeURIComponent(req.query.type)&#125;`); &#125;); DOM型XSSDOM 型 XSS 攻击，实际上就是前端 JavaScript 代码不够严谨，把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等。 DOM 型 XSS 的攻击步骤： 1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码。3.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 如何防范 DOM 型 XSS 攻击 防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。 1.对于url链接(例如图片的src属性)，那么直接使用 encodeURIComponent 来转义。 2.非url，我们可以这样进行编码： 123456function encodeHtml(str) &#123; return str.replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;apos;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;');&#125; DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。 存储型XSS恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。 存储型 XSS 的攻击步骤： 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 如何防范存储型XSS攻击： 1.前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)2.服务器接收到数据，在存储到数据库之前，进行转义/过滤3.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤 XSS其他防范手段1.Content Security Policy 在服务端使用 HTTP的 Content-Security-Policy 头部来指定策略，或者在前端设置 meta 标签。 例如下面的配置只允许加载同域下的资源： 1Content-Security-Policy: default-src 'self' 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"form-action 'self';\"&gt; 前端和服务端设置 CSP 的效果相同，但是meta无法使用report 严格的 CSP 在 XSS 的防范中可以起到以下的作用： 1.禁止加载外域代码，防止复杂的攻击逻辑。2.禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。3.禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。4.禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。5.合理使用上报可以及时发现 XSS，利于尽快修复问题。 2.输入内容长度控制 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 3.输入内容限制 对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。 4.其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 XSS检测1.使用通用 XSS 攻击字串手动检测 XSS 漏洞 1如: javascript:/*-/*`/*\\`/*&apos;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e 能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。 1&lt;img src=1 onerror=alert(1)&gt; 2.使用第三方工具进行扫描 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 典型的CSRF攻击流程： 1.受害者登录A站点，并保留了登录凭证（Cookie）。2.攻击者诱导受害者访问了站点B。3.站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。4.站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。5.站点A以受害者的名义执行了站点B的请求。6.攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。 CSRF的特点 1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击) CSRF 攻击防御 添加验证码(体验不好)验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。 判断请求的来源：检测Referer(并不安全，Referer可以被更改)Referer 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 Referer 本身是可以被修改的，因为不能仅依赖于 Referer 使用Token(主流)CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。 服务端给用户生成一个token，加密后传递给用户 用户在提交请求时，需要携带这个token 服务端验证token是否正确 Samesite Cookie属性为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。Samesite=StrictSamesite=Strict 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。 123**Samesite=Lax**`Samesite=Lax` 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 `Get` / `OPTIONS` 、`HEAD` 请求.但是不安全 HTTP 方法，如： `POST`, `PUT`, `DELETE` 请求时，不能作为第三方链接的 Cookie 为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"web其他","slug":"web其他","permalink":"http://yoursite.com/tags/web其他/"}]}]}