{"meta":{"title":"EvanYang's Blog","subtitle":null,"description":null,"author":"Evan Yang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:33:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章标记","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:33:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"正则表达式","slug":"js基础-正则表达式","date":"2019-05-19T16:00:00.000Z","updated":"2019-05-22T06:30:09.000Z","comments":true,"path":"2019/05/20/js基础-正则表达式/","link":"","permalink":"http://yoursite.com/2019/05/20/js基础-正则表达式/","excerpt":"","text":"正则表达式语法123var regexp = new RegExp(pattern, modifiers)var regexp = /pattern/modifiers 需要转义的字符(使用\\转义) .(点号), ()(小括号), [](中括号), /(左斜杠), \\(右斜杠), |(选择匹配符), *, ?, {}, +, $, - 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [xxx] 查找给定集合内的任何字符。 [^xxx] 查找给定集合外的任何字符。 元字符 表达式 描述 . 匹配出”\\n”(换行符)之外的任何单个字符 \\w 匹配包括下划线的任何字母,数字,下划线字符,还可以使用[0-9a-zA-Z_] \\W 匹配任何非字母,数字,下划线字符,还可以使用[^\\w] \\d 匹配一个数字字符,与使用[0-9]等价 \\D 匹配一个非数字字符,还可使用[^0-9] \\s 匹配任何空白字符 \\S 匹配任何非空白字符，还可使用[^\\s] [\\u4e00-\\u9fa5] 匹配中文字符 \\n，\\r，\\f，\\t，\\v 匹配换行符, 回车符, 换页符, 制表符, 垂直制表符 \\b 匹配单词边界 \\B 匹配非单词边界 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 表达式 描述 * 匹配前面的子表达式0次或多次 (0或1) + 匹配前面的子表达式1次或多次 (1或多) ? 匹配前面的子表达式0次或1次 (0或1) {n} 匹配确定n次 {n,} 至少匹配n次 {n,m} 最少匹配n次，最多匹配m次 ^x 匹配任何开头为x的字符串 x$ 匹配任何结尾为x的字符串 贪婪和惰性模式 贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab.*c)。 惰性匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab.*c)。 贪婪模式的量词: *, +, ?, {n}, {n,}, {n,m} 惰性模式的量词: *?, +?, ??, {n}?, {n,}?, {n,m}? 分组在正则表达式中用（）包起来的内容代表了一个分组，像这样的：123var reg = /(\\d&#123;2&#125;)/reg.test('12'); // true// 这里reg中的(/d&#123;2&#125;)就表示一个分组，匹配两位数字 分组类型 捕获型 () 非捕获型 (?:) 正向前瞻性 (?=) 反向前瞻性 (?!)我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串 分组的应用 捕获型与引用($1~$n) 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串： 1234567var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/var dateStr = '2019-05-20'reg.test(dateStr) // trueRegExp.$1 // 2019RegExp.$2 // 05RegExp.$3 // 20RegExp.$4 // \"\" 反向引用(\\1~\\n) 正则表达式里也能进行引用，这称为反向引用： 12345678910var reg = /(\\w&#123;3&#125;) is \\1/reg.test('kid is kig') // truereg.test('dik is dik') // truereg.test('kid is dik') // falsreg.test('dik is kid') // false// todo 如果引用越界或者不存在的编号，就被解析为普通的表达式var reg = /(\\w&#123;3&#125;) is \\6/reg.test('kid is kid') // falsereg.test('kid is \\6') // true 非捕获型分组 使用分组并且不要捕获(即分组后不能是$1-$n去获取),使用?:,例如： 12345var reg = /(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/var date = '2019-05-20'reg.test(date)RegExp.$1 // 05RegExp.$2 // 20 正向前瞻性分组 (?=patter),匹配字符后紧跟patter返回true,否则为false 123var reg = /kid is a (?=doubi)/reg.test('kid is a doubi') // truereg.test('kid is a shabi') // true 反向前瞻型分组 (?!patter),匹配字符后不紧跟patter返回true,否则为false 123var reg = /kid is a (?!doubi)/reg.test('kid is a doubi') // falsereg.test('kid is a shabi') // true 非捕获型和(正向前瞻,反向前瞻)区别 非捕获型和(正向前瞻,反向前瞻)都不会捕获 12345678910var regvar str = 'kid is a doubi'reg = /(kid is a (?:doubi))/reg.test(str)RegExp.$1 // kid is a doubireg = /(kid is a (?=doubi))/reg = /(kid is a (?!doubi))/reg.test(str)RegExp.$1 // kid is a 也就是说非捕获型分组匹配到的字符串任然会被外层分组匹配到，而前瞻型不会，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。 正则方法 RegExp 对象方法 方法 描述 exec 检索字符串中指定的值。返回找到的值，并确定其位置。 test 检索字符串中指定的值。返回 true 或 false。 toString 返回正则表达式的字符串。 正则表达式String对象的方法 方法 描述 search 检索与正则表达式相匹配的值。 match 找到一个或多个正则表达式的匹配。 replace 替换与正则表达式匹配的子串。 split 把字符串分割为字符串数组。 RegExp 对象属性 方法 描述 constructor 返回一个函数，该函数是一个创建 RegExp 对象的原型。 global 判断是否设置了 “g” 修饰符 ignoreCase 判断是否设置了 “i” 修饰符 multiline 判断是否设置了 “m” 修饰符 source 返回正则表达式的匹配模式 lastIndex 用于规定下次匹配的起始位置 1234567891011121314151617181920例子：sourcevar patt = /ani/gpatt.test('This is a ani')console.log(patt.source) // ani例子：lastIndexvar patt = /ani/gconsole.log(patt.lastIndex) // 0patt.test('This is a ani') // trueconsole.log(patt.lastIndex) // 13// 因为当前的lastIndex(匹配其实位置为13,所以从第13位开始查找,匹配不到默认重置为0)patt.test('This is a ani') // falseconsole.log(patt.lastIndex) // 0patt.test('This is is is is is a ani') // true解决方法：在匹配前重置lastIndex: patt.lastIndex = 0 patt.test('This is a ani') // true不要使用定义的变量缓存正则表达式： /ani/g.test('This is a ani')","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://yoursite.com/categories/javascript基础/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Git常用命令","slug":"文档使用-Git常用命令","date":"2019-05-19T16:00:00.000Z","updated":"2019-05-23T08:59:34.000Z","comments":true,"path":"2019/05/20/文档使用-Git常用命令/","link":"","permalink":"http://yoursite.com/2019/05/20/文档使用-Git常用命令/","excerpt":"","text":"Git 常用命令 Git主要包含三个区 工作区(working diretory) 用于修改文件 缓存区(stage) 是用来暂时存放工作区中修改的内容 提交历史（commit history） 提交代码的历史记录 git一般配置1234567git --version // 查看git版本git config --global user.name // 获取当前登录的用户名git config --global user.email // 获取当前登录用户的邮箱// 如果刚没有获取到用户配置，则只能拉取代码，不能修改 要是使用git，你要告诉git是谁在使用git config --global user.name 'userName' // 设置git账户，userName为你的git账号git config --global user.email 'email' 1.初始化git仓库 git init：在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. 2.创建忽略文件 touch .gitignore：不需要服务器端提交的内容可以写到忽略文件里 3.克隆远程代码 git clone [url]：获取一个url对应的远程Git repo, 创建一个local copy. 4.拉取代码 git pull 5.推送至远程代码 git push git新建,切换分支(branch,checkout) git branch git branch：查看所有本地分支 git branch -r：查看所有远程分支 git branch -a：查看所有本地，远程分支 git branch dev：新建本地dev分支，不切换当前分支 git branch -m dev version：修改本地分支dev名称为version git checkout git checkout dev：切换分支到dev git checkout -b dev：新建dev分支，并切换当前分支到dev分支 git checkout .：把当前分支没有暂存的所有修改文件，恢复成未修改是的样子 新增本地分支推送到远程流程 git branch dev || git checkout -b dev：新增dev分支 git push --set-upstream origin dev || git push -u origin dev：建立本地到远端仓的链接(建立链接后，以后提交远端直接git push即可) 删除本地和远程分支 git branch -d(--delete) dev：删除本地dev分支 git push origin --delete dev || git push origin :dev：删除远程dev分支 git暂存区(add) git add *：提交所有变化,包括文件修改(modified)以及新文件(new),但不包括被删除的文件 git add -u(–update)：提交被修改(modified)和被删除(deleted)文件,不包括新文件(new) git add ., git add -A(–all)：提交新文件和被修改文件,被删除文件 git提交本地(commit) git commit -m &#39;message&#39;：提交已经过git add的文件到本地版本库 git commit -a -m &#39;message&#39;：提交进过git add和没有进过git add的文件到本地版本库 git commit --amend -m &#39;message&#39;：不新增commit提交记录，覆盖上一次提交记录 git回滚代码(reset,revert) reset(版本回撤) reset 会重置并删除回撤的提交历史记录 git reset --soft：回退版本库,到暂存区 git reset --mixed：回退版本库，暂存区,到工作区。(–mixed为git reset的默认参数，即当任何参数都不加的时候的参数) git reset --hard：回退版本库，暂存区，工作区。（因此我们修改过的代码就没了，需要谨慎使用） git reset HEAD(head)~1 || git reset commit_id：使用head~n回滚到第n次提交，或者commit_id revert(撤销操作) revert 不会重置提交的历史记录，会创建一个新的提交。 git revert HEAD(head)~1 || git revert commit_id：使用head~n回滚到第n次提交，或者commit_id git revert --continue git revert --abort：如果不想解决冲突的话可以取消撤回 git revert --quit git代码合并(merge,rebase) merge合并策略 git merge [-s 合并策略] [-x 合并策略参数] &lt;commit&gt;... resolve(合并策略)：只能用于两个分支的合并，这个合并策略被认为是最安全、最快的合并策略 recursive(合并策略)：只能用于两个分支的合并，两个分支的合并默认使用该策略。该策略可以使用选项： ours(合并策略参数)：在遇到冲突的时候，选择当前分支的版本，而忽略远程合并过来的版本。 theirs(合并策略参数)：和ours选项相反 subtree=path：使用子树合并策略 octpus(合并策略)：用于合并两个以上分支的策略，该策略拒绝执行需要手动解决的复杂合并。 ours(合并策略参数)：可以用于任意多个分支的合并策略，合并的结果总是使用当前分支的内容而丢弃远程合并过来的版本内容 subtree(合并策略参数)：这是一个经过调整后的recursive策略 例子如下：12// 当前分支合并dev分支，有冲突完全接受dev分支的代码git merge -s recursive -x theirs dev rebase git rebase","categories":[{"name":"文档使用","slug":"文档使用","permalink":"http://yoursite.com/categories/文档使用/"}],"tags":[{"name":"Git常用命令","slug":"Git常用命令","permalink":"http://yoursite.com/tags/Git常用命令/"}]},{"title":"markdowm使用文档","slug":"文档使用-markdowm文档","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-20T03:29:49.000Z","comments":true,"path":"2019/05/11/文档使用-markdowm文档/","link":"","permalink":"http://yoursite.com/2019/05/11/文档使用-markdowm文档/","excerpt":"","text":"欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter文档管理 Cmd + O系统菜单 Cmd + M 加粗 Cmd + B插入图片 Cmd + G插入链接 Cmd + L提升标题 Cmd + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#x75;&#115;&#x74;&#103;&#111;&#x63;&#107;&#x40;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[{"name":"文档使用","slug":"文档使用","permalink":"http://yoursite.com/categories/文档使用/"}],"tags":[{"name":"markdowm","slug":"markdowm","permalink":"http://yoursite.com/tags/markdowm/"}]},{"title":"css基础","slug":"面试-css","date":"2018-04-29T16:00:00.000Z","updated":"2019-05-20T03:34:44.000Z","comments":true,"path":"2018/04/30/面试-css/","link":"","permalink":"http://yoursite.com/2018/04/30/面试-css/","excerpt":"","text":"","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"css面试题","slug":"css面试题","permalink":"http://yoursite.com/tags/css面试题/"}]},{"title":"web安全类","slug":"面试-web安全","date":"2018-04-29T16:00:00.000Z","updated":"2019-05-16T01:50:40.000Z","comments":true,"path":"2018/04/30/面试-web安全/","link":"","permalink":"http://yoursite.com/2018/04/30/面试-web安全/","excerpt":"","text":"XSS攻击XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。 XSS分类 根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击： 反射型XSS当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。 反射型XSS的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 如何防范反射型XSS攻击 对字符串进行编码。 对url的查询参数进行转义后再输出到页面。 1234app.get('/welcome', function(req, res) &#123; //对查询参数进行编码，避免反射型 XSS攻击 res.send(`$&#123;encodeURIComponent(req.query.type)&#125;`); &#125;); DOM型XSSDOM 型 XSS 攻击，实际上就是前端 JavaScript 代码不够严谨，把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等。 DOM 型 XSS 的攻击步骤： 1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码。3.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 如何防范 DOM 型 XSS 攻击 防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。 1.对于url链接(例如图片的src属性)，那么直接使用 encodeURIComponent 来转义。 2.非url，我们可以这样进行编码： 123456function encodeHtml(str) &#123; return str.replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;apos;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;');&#125; DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。 存储型XSS恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。 存储型 XSS 的攻击步骤： 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 如何防范存储型XSS攻击： 1.前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)2.服务器接收到数据，在存储到数据库之前，进行转义/过滤3.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤 XSS其他防范手段1.Content Security Policy 在服务端使用 HTTP的 Content-Security-Policy 头部来指定策略，或者在前端设置 meta 标签。 例如下面的配置只允许加载同域下的资源： 1Content-Security-Policy: default-src 'self' 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"form-action 'self';\"&gt; 前端和服务端设置 CSP 的效果相同，但是meta无法使用report 严格的 CSP 在 XSS 的防范中可以起到以下的作用： 1.禁止加载外域代码，防止复杂的攻击逻辑。2.禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。3.禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。4.禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。5.合理使用上报可以及时发现 XSS，利于尽快修复问题。 2.输入内容长度控制 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 3.输入内容限制 对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。 4.其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 XSS检测1.使用通用 XSS 攻击字串手动检测 XSS 漏洞 1如: javascript:/*-/*`/*\\`/*&apos;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e 能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。 1&lt;img src=1 onerror=alert(1)&gt; 2.使用第三方工具进行扫描 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 典型的CSRF攻击流程： 1.受害者登录A站点，并保留了登录凭证（Cookie）。2.攻击者诱导受害者访问了站点B。3.站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。4.站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。5.站点A以受害者的名义执行了站点B的请求。6.攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。 CSRF的特点 1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击) CSRF 攻击防御 添加验证码(体验不好)验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。 判断请求的来源：检测Referer(并不安全，Referer可以被更改)Referer 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 Referer 本身是可以被修改的，因为不能仅依赖于 Referer 使用Token(主流)CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。 服务端给用户生成一个token，加密后传递给用户 用户在提交请求时，需要携带这个token 服务端验证token是否正确 Samesite Cookie属性为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。Samesite=StrictSamesite=Strict 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。 123**Samesite=Lax**`Samesite=Lax` 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 `Get` / `OPTIONS` 、`HEAD` 请求.但是不安全 HTTP 方法，如： `POST`, `PUT`, `DELETE` 请求时，不能作为第三方链接的 Cookie 为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。 点击劫持点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。 典型点击劫持攻击流程1.攻击者构建了一个非常有吸引力的网页【不知道哪些内容对你们来说有吸引力，我就不写页面了，偷个懒】2.将被攻击的页面放置在当前页面的 iframe 中3.使用样式将 iframe 叠加到非常有吸引力内容的上方4.将iframe设置为100%透明5.你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。 点击劫持防御1.frame busting123if ( top.location != window.location )&#123; top.location = window.location&#125; 需要注意的是: HTML5中iframe的 sandbox 属性、IE中iframe的security 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。 X-Frame-Options X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。 可以设置为以下值: DENY: 拒绝任何域加载 SAMEORIGIN: 允许同源域下加载 ALLOW-FROM: 可以定义允许frame加载的页面地址 安全扫描工具1.Arachni Arachni是基于Ruby的开源，功能全面，高性能的漏洞扫描框架，Arachni提供简单快捷的扫描方式，只需要输入目标网站的网址即可开始扫描。它可以通过分析在扫描过程中获得的信息，来评估漏洞识别的准确性和避免误判。Arachni默认集成大量的检测工具，可以实施 代码注入、CSRF、文件包含检测、SQL注入、命令行注入、路径遍历等各种攻击。同时，它还提供了各种插件，可以实现表单爆破、HTTP爆破、防火墙探测等功能。针对大型网站，该工具支持会话保持、浏览器集群、快照等功能，帮助用户更好实施渗透测试 2.Mozilla HTTP Observatory Mozilla HTTP Observatory，是Mozilla最近发布的一款名为Observatory的网站安全分析工具，意在鼓励开发者和系统管理员增强自己网站的安全配置。用法非常简单：输入网站URL，即可访问并分析网站HTTP标头，随后可针对网站安全性提供数字形式的分数和字母代表的安全级别。 Cookie 跨源资源共享（CORS） 内容安全策略（CSP） HTTP公钥固定（Public Key Pinning） HTTP严格安全传输（HSTS）状态 是否存在HTTP到HTTPs的自动重定向 子资源完整性（Subresource Integrity） X-Frame-Options X-XSS-Protection 3. w3af W3af是一个基于Python的Web应用安全扫描器。可帮助开发人员，有助于开发人员和测试人员识别Web应用程序中的漏洞。扫描器能够识别200多个漏洞，包括跨站点脚本、SQL注入和操作系统命令。","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"web其他","slug":"web其他","permalink":"http://yoursite.com/tags/web其他/"}]}]}