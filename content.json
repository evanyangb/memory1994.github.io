{"meta":{"title":"EvanYang's Blog","subtitle":null,"description":null,"author":"Evan Yang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"文章分类","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:33:58.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"文章标记","date":"2019-05-12T16:00:00.000Z","updated":"2019-05-14T06:33:31.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iconfont优雅使用","slug":"文档使用-icon优雅使用","date":"2019-06-05T07:26:11.000Z","updated":"2019-06-05T09:08:55.000Z","comments":true,"path":"2019/06/05/文档使用-icon优雅使用/","link":"","permalink":"http://yoursite.com/2019/06/05/文档使用-icon优雅使用/","excerpt":"","text":"演进史首先我们来说一下前端 icon 的发展史。 远古时代在我刚开始实习时，大部分图标都是用 img 来实现的。渐渐发现一个页面的请求资源中图片 img 占了大部分，所以为了优化有了image sprite 就是所谓的雪碧图，就是将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。但这个也有一个很大的痛点，维护困难。每新增一个图标，都需要改动原始图片，还可能不小心出错影响到前面定位好的图片，而且一修改雪碧图，图片缓存就失效了，久而久之你不知道该怎么维护了。 font 库后来渐渐地一个项目里几乎不会使用任何本地的图片了，而使用一些 font 库来实现页面图标。常见的如 Font Awesome ，使用起来也非常的方便，但它有一个致命的缺点就是找起来真的很不方便，每次找一个图标特别的费眼睛，还有就是它的定制性也非常的不友善，它的图标库一共有675个图标，说少也不少，但还是会常常出现找不到你所需要图标的情况。当然对于没有啥特别 ui 追求的初创公司来说还是能忍一忍的。但随着公司的壮大，来了越来越多对前端指手画脚的人，丧心病狂的设计师，他们会说不！这icon这么丑，这简直是在侮辱他们高级设计师的称号啊！不过好在这时候有了iconfont 。 iconfont一个阿里爸爸做的开源图库，人家还有专门的 github issue(虽然我的一个 issue 半年多了也没回应/(ㄒoㄒ)/~~)，但人家的图标数量还是很惊人的，不仅有几百个公司的开源图标库，还有各式各样的小图标，还支持自定义创建图标库，所以不管你是一家创业公司还是对设计很有要求的公司，它都能很好的帮助你解决管理图标的痛点。你想要的基本都有~ iconfont 三种使用姿势unicode最开始我们使用了unicode的格式，它主要的特点是优势 兼容性最好，支持ie6+ 支持按字体的方式去动态调整图标大小，颜色等等 劣势 不支持多色图标 在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对文字的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难 使用方法：第一步：引入自定义字体 `font-face @font-face { font-family: &lt;span class=&quot;hljs-string&quot;&gt;&quot;iconfont&quot;&lt;/span&gt;; src: url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.eot&apos;&lt;/span&gt;); /* IE9*/ src: url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.eot#iefix&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;embedded-opentype&apos;&lt;/span&gt;), /* IE6-IE8 */ url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.woff&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;woff&apos;&lt;/span&gt;), /* chrome, firefox */ url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.ttf&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;truetype&apos;&lt;/span&gt;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.svg#iconfont&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;svg&apos;&lt;/span&gt;); /* iOS 4.1- */ } &lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;`&lt;/pre&gt; 第二步：定义使用iconfont的样式 &lt;pre&gt;`.iconfont { font-family:&lt;span class=&quot;hljs-string&quot;&gt;&quot;iconfont&quot;&lt;/span&gt; !important; font-size:16px; font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale; } &lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;`&lt;/pre&gt; 第三步：挑选相应图标并获取字体编码，应用于页面 &lt;pre&gt;`&amp;lt;i class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;iconfont&quot;&lt;/span&gt;&amp;gt;&amp;amp;&lt;span class=&quot;hljs-comment&quot;&gt;#xe604;&amp;lt;/i&amp;gt;&lt;/span&gt; &lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;`&lt;/pre&gt; 效果图： &lt;figure&gt;{% image https://user-gold-cdn.xitu.io/2017/10/19/212123363f183d2984e314cc89b9e113?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 '' '' %}&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt; 其实它的原理也很简单，就是通过 `@font-face` 引入自定义字体(其实就是一个字体库)，它里面规定了`&amp;amp;#xe604` 这个对应的形状就长这企鹅样。其实类似于 &apos;花裤衩&apos;，在不同字体设定下长得是不同的一样。 &lt;figure&gt;{% image https://user-gold-cdn.xitu.io/2017/10/19/d142cf85062436fadef23bae4e3eafb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 '' '' %}&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt; 不过它的缺点也显而易见，`unicode`的书写不直观，语意不明确。光看`&amp;amp;#xe604;`这个`unicode`你完全不知道它代表的是什么意思。这时候就有了 `font-class`。 ### font-class 与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+ 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 使用方法：第一步：拷贝项目下面生成的fontclass代码： `../font_8d5l8fzk5b87iudi.css 复制代码` 第二步：挑选相应图标并获取类名，应用于页面： `&lt;i class=\"iconfont icon-xxx\"&gt;&lt;/i&gt; 复制代码` 效果图： image.png 它的主要原理其实是和 unicode 一样的，它只是多做了一步，将原先&amp;amp;#xe604这种写法换成了.icon-QQ，它在每个 class 的 before 属性中写了unicode,省去了人为写的麻烦。如 .icon-QQ:before { content: &quot;\\e604&quot;; } 相对于unicode 它的修改更加的方便与直观。但也有一个大坑，之前楼主一个项目中用到了两组font-class 由于没有做好命名空间，所有的class都是放在.iconfont 命名空间下的，一上线引发了各种雪崩问题，修改了半天，所以使用font-class一定要注意命名空间的问题。 symbol随着万恶的某某浏览器逐渐淡出历史舞台，svg-icon 使用形式慢慢成为主流和推荐的方法。相关文章可以参考张鑫旭大大的文章未来必热：SVG Sprite技术介绍 支持多色图标了，不再受单色限制。 支持像字体那样通过font-size,color来调整样式。 支持 ie9+ 可利用CSS实现动画。 减少HTTP请求。 矢量，缩放不失真 可以很精细的控制SVG图标的每一部分 使用方法：第一步：拷贝项目下面生成的symbol代码： `引入 ./iconfont.js 复制代码` 第二步：加入通用css代码（引入一次就行）： `&lt;style type=\"text/css\"&gt; .icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } &lt;/style&gt; 复制代码` 第三步：挑选相应图标并获取类名，应用于页面： `&lt;svg class=\"icon\" aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#icon-xxx\"&gt;&lt;/use&gt; &lt;/svg&gt; 复制代码` 使用svg-icon的好处是我再也不用发送woff|eot|ttf| 这些很多个字体库请求了，我所有的svg都可以内联在html内。 还有一个就是 svg 是一个真正的矢量，不管你再怎么的放缩它都不会失真模糊，而且svg可以控制的属性也更加的丰富，也能做出更加生动和复杂的图标。现在ui设计师平时都喜欢使用 sketch 来工作，只要轻松一键就能导出 svg 了，所以 svg 也更受设计师的青睐。Inline SVG vs Icon Fonts 这篇文章详细的比较了 svg 和 icon-font的优劣，大家可以去看看。PS：这里其实还用到了 SVG Sprite 技术。简单的理解就是类 svg 的似雪碧图，它在一个 svg 之中运用 symbol 标示了一个一个的 svg 图标，这样一个页面中我们遇到同样的 svg 就不用重复再画一个了，直接使用&amp;lt;use xlink:href=&quot;#icon-QQ&quot; x=&quot;50&quot; y=&quot;50&quot; /&amp;gt; 就能使用了，具体的细节可以看这篇文章开头的文章 未来必热：SVG Sprite技术介绍，在之后的文章中也会手摸手叫你自己如何制作 SVG Sprite。 创建 icon-component 组件我们有了图标，接下来就是如何在自己的项目中优雅的使用它了。之后的代码都是基于 vue 的实例(ps: react 也很简单，原理都是类似的) `//components/Icon-svg &lt;template&gt; &lt;svg class=\"svg-icon\" aria-hidden=\"true\"&gt; &lt;use :xlink:href=\"iconName\"&gt;&lt;/use&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'icon-svg', props: { iconClass: { type: String, required: true } }, computed: { iconName() { return `#icon-${this.iconClass}` } } } &lt;/script&gt; &lt;style&gt; .svg-icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } &lt;/style&gt; 复制代码``//引入svg组件 import IconSvg from '@/components/IconSvg' //全局注册icon-svg Vue.component('icon-svg', IconSvg) //在代码中使用 &lt;icon-svg icon-class=\"password\" /&gt; 复制代码` 就这样简单封装了一个 Icon-svg 组件 ，我们就可以简单优雅的在自己的vue项目之中使用图标了。 进一步改造但作为一个有逼格的前端开发，怎能就此满足呢!目前还是有一个致命的缺点的，就是现在所有的 svg-sprite 都是通过 iconfont 的 iconfont.js 生成的。 首先它是一段用js来生成svg的代码，所有图标 icon 都很不直观。 如图所示 你完全不知道哪个图标名对应什么图标，一脸尼克扬问号??? 每次增删改图标只能整体js文件一起替换。 其次它也做不到按需加载，不能根据我们使用了那些 svg 动态的生成 svg-sprite。 自定义性差，通常导出的svg包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容。 添加不友善，如果我有一些自定义的svg图标，该如何和原有的 iconfont 整合到一起呢？目前只能将其也上传到 iconfont 和原有的图标放在一个项目库中，之后再重新下载，很繁琐。 使用 svg-sprite接下来我们就要自己来制作 svg-sprite 了。这里要使用到 svg-sprite-loader 这个神器了， 它是一个 webpack loader ，可以将多个 svg 打包成 svg-sprite 。 我们来介绍如何在 vue-cli 的基础上进行改造，加入 svg-sprite-loader。 我们发现vue-cli默认情况下会使用 url-loader 对svg进行处理，会将它放在/img 目录下，所以这时候我们引入svg-sprite-loader 会引发一些冲突。 `//默认`vue-cli` 对svg做的处理，正则匹配后缀名为.svg的文件，匹配成功之后使用 url-loader 进行处理。 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } } 复制代码` 解决方案有两种，最简单的就是你可以将 test 的 svg 去掉，这样就不会对svg做处理了，当然这样做是很不友善的。 你不能保证你所有的 svg 都是用来当做 icon的，有些真的可能只是用来当做图片资源的。 不能确保你使用的一些第三方类库会使用到 svg。 所以最安全合理的做法是使用 webpack 的 exclude 和 include ，让svg-sprite-loader只处理你指定文件夹下面的 svg，url-loaer只处理除此文件夹之外的所以 svg，这样就完美解决了之前冲突的问题。代码如下 这样配置好了，只要引入svg之后填写类名就可以了 `import '@/src/icons/qq.svg; //引入图标 &lt;svg&gt;&lt;use xlink:href=\"#qq\" /&gt;&lt;/svg&gt; //使用图标 复制代码` 单这样还是非常的不优雅，如果我项目中有一百个 icon，难不成我要手动一个个引入么！ 偷懒是程序员的第一生产力！！！ 自动导入首先我们创建一个专门放置图标 icon 的文件夹如：@/src/icons，将所有 icon 放在这个文件夹下。之后我们就要使用到 webpack 的 require.context。很多人对于 require.context可能比较陌生，直白的解释就是 require.context(“./test”, false, /.test.js$/); 这行代码就会去 test 文件夹（不包含子目录）下面的找所有文件名以 `.test.js` 结尾的文件能被 require 的文件。 更直白的说就是 我们可以通过正则匹配引入相应的文件模块。 require.context有三个参数： directory：说明需要检索的目录 useSubdirectories：是否检索子目录 regExp: 匹配文件的正则表达式 了解这些之后，我们就可以这样写来自动引入 @/src/icons 下面所有的图标了 `const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context(‘./svg’, false, /.svg$/)requireAll(req)复制代码 之后我们增删改图标直接直接文件夹下对应的图标就好了，什么都不用管，就会自动生成 svg symbol了。 更进一步优化自己的svg首先我们来看一下 从 阿里iconfont 网站上导出的 svg 长什么样？ 没错虽然 iconfont 网站导出的 svg 内容已经算蛮精简的了，但你会发现其实还是与很多无用的信息，造成了不必要的冗余。就连 iconfont 网站导出的 svg 都这样，更不用说那些更在意 ui漂不漂亮不懂技术的设计师了(可能)导出的svg了。好在 svg-sprite-loader也考虑到了这点，它目前只会获取 svg 中 path 的内容，而其它的信息一概不会获取。生成 svg 如下图： 但任何你在 path 中产生的冗余信息它就不会做处理了。如注释什么的 这时候我们就要使用另一个很好用的东西了– svgo SVG files, especially exported from various editors, usually contain a lot of redundant and useless information such as editor metadata, comments, hidden elements, default or non-optimal values and other stuff that can be safely removed or converted without affecting SVG rendering result. 它支持几十种优化项，非常的强大，8k+的star 也足以说明了问题。 详细的操作可以参照 官方文档 张鑫旭大大的文章（没错又是这位大大的文章，或许这就是大佬吧！）本文就不展开了。 写在最后上面大概阐述了一下前端项目中 icon 使用的演进史。总的来说还是那句话，适合的才是最好的。就拿之前争论的选择 vue react 还是 angular，个人觉得每个框架都有自己的特点和适用的业务场景，所以所有不结合业务场景的推荐和讨论都是瞎bb。。。如上文其实大概讲了五种前端icon的使用场景，第一种Font Awesome不用它并不是因为它不好，而是业务场景不适合，如果你团队没有专门的设计师或者对 icon 的自定义度不高完全可以使用它，Font Awesome github有五万多 star，足见社区对它的认可。还比如说，你们项目对低端浏览器有较高的适配要求，你还强行要用 svg 作为图标 icon，那你真的是存心和自己过不去了。所以所有方案都没有绝对的优与劣之分，适合自己业务场景，解决自己实际痛点，提高自己开发效率的方案就是好的方案。","categories":[{"name":"文档使用","slug":"文档使用","permalink":"http://yoursite.com/categories/文档使用/"}],"tags":[{"name":"iconfont","slug":"iconfont","permalink":"http://yoursite.com/tags/iconfont/"}]},{"title":"es6基础","slug":"js基础-ecmascript6","date":"2019-05-19T16:00:00.000Z","updated":"2019-07-01T04:00:50.662Z","comments":true,"path":"2019/05/20/js基础-ecmascript6/","link":"","permalink":"http://yoursite.com/2019/05/20/js基础-ecmascript6/","excerpt":"","text":"ECMAScript6小结1.块级绑定(let,const) let和const声明 let声明的是变量的块级作用域，const声明的是常量的块级作用域，都不会进行变量提升 禁止重复声明 ES6 允许块级作用域的任意嵌套。 123&#123;&#123;&#123; let insane = 'Hello world'&#125;&#125;&#125; 内层作用域可以定义外层作用域的同名变量。 123456&#123; let insane = 'Hello world' &#123; let insame = '我是内层' &#125;&#125; let和const声明都有暂时性死区 1234567891011// 在达到声明处之前都是无法访问的，试图访问会导致一个引用错误，即使是使用typeof运算符if (condition) &#123; console.log(typeof value) // 引用错误 console.log(value) // 引用错误 let value = \"blue\"&#125;当JS引擎检视代码块并发现变量声明时，它会在面对var的情况下将声明提升到函数或全局作用域的顶部而面对let或const时会将声明放在`暂时性死区内`。任何在暂时性死区内的声明,试图访问变量都会导致\"运行时\"错误(runtime error)。只有执行到变量的声明语句时，该声明的变量才会从暂时性死区内被移除并可以安全使用。 循环中的块级绑定","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://yoursite.com/categories/javascript基础/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"Git常用命令","slug":"文档使用-Git常用命令","date":"2019-05-19T16:00:00.000Z","updated":"2019-05-23T08:59:34.000Z","comments":true,"path":"2019/05/20/文档使用-Git常用命令/","link":"","permalink":"http://yoursite.com/2019/05/20/文档使用-Git常用命令/","excerpt":"","text":"Git 常用命令 Git主要包含三个区 工作区(working diretory) 用于修改文件 缓存区(stage) 是用来暂时存放工作区中修改的内容 提交历史（commit history） 提交代码的历史记录 git一般配置1234567git --version // 查看git版本git config --global user.name // 获取当前登录的用户名git config --global user.email // 获取当前登录用户的邮箱// 如果刚没有获取到用户配置，则只能拉取代码，不能修改 要是使用git，你要告诉git是谁在使用git config --global user.name 'userName' // 设置git账户，userName为你的git账号git config --global user.email 'email' 1.初始化git仓库 git init：在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹. 2.创建忽略文件 touch .gitignore：不需要服务器端提交的内容可以写到忽略文件里 3.克隆远程代码 git clone [url]：获取一个url对应的远程Git repo, 创建一个local copy. 4.拉取代码 git pull 5.推送至远程代码 git push git新建,切换分支(branch,checkout) git branch git branch：查看所有本地分支 git branch -r：查看所有远程分支 git branch -a：查看所有本地，远程分支 git branch dev：新建本地dev分支，不切换当前分支 git branch -m dev version：修改本地分支dev名称为version git checkout git checkout dev：切换分支到dev git checkout -b dev：新建dev分支，并切换当前分支到dev分支 git checkout .：把当前分支没有暂存的所有修改文件，恢复成未修改是的样子 新增本地分支推送到远程流程 git branch dev || git checkout -b dev：新增dev分支 git push --set-upstream origin dev || git push -u origin dev：建立本地到远端仓的链接(建立链接后，以后提交远端直接git push即可) 删除本地和远程分支 git branch -d(--delete) dev：删除本地dev分支 git push origin --delete dev || git push origin :dev：删除远程dev分支 git暂存区(add) git add *：提交所有变化,包括文件修改(modified)以及新文件(new),但不包括被删除的文件 git add -u(–update)：提交被修改(modified)和被删除(deleted)文件,不包括新文件(new) git add ., git add -A(–all)：提交新文件和被修改文件,被删除文件 git提交本地(commit) git commit -m &#39;message&#39;：提交已经过git add的文件到本地版本库 git commit -a -m &#39;message&#39;：提交进过git add和没有进过git add的文件到本地版本库 git commit --amend -m &#39;message&#39;：不新增commit提交记录，覆盖上一次提交记录 git回滚代码(reset,revert) reset(版本回撤) reset 会重置并删除回撤的提交历史记录 git reset --soft：回退版本库,到暂存区 git reset --mixed：回退版本库，暂存区,到工作区。(–mixed为git reset的默认参数，即当任何参数都不加的时候的参数) git reset --hard：回退版本库，暂存区，工作区。（因此我们修改过的代码就没了，需要谨慎使用） git reset HEAD(head)~1 || git reset commit_id：使用head~n回滚到第n次提交，或者commit_id revert(撤销操作) revert 不会重置提交的历史记录，会创建一个新的提交。 git revert HEAD(head)~1 || git revert commit_id：使用head~n回滚到第n次提交，或者commit_id git revert --continue git revert --abort：如果不想解决冲突的话可以取消撤回 git revert --quit git代码合并(merge,rebase) merge合并策略 git merge [-s 合并策略] [-x 合并策略参数] &lt;commit&gt;... resolve(合并策略)：只能用于两个分支的合并，这个合并策略被认为是最安全、最快的合并策略 recursive(合并策略)：只能用于两个分支的合并，两个分支的合并默认使用该策略。该策略可以使用选项： ours(合并策略参数)：在遇到冲突的时候，选择当前分支的版本，而忽略远程合并过来的版本。 theirs(合并策略参数)：和ours选项相反 subtree=path：使用子树合并策略 octpus(合并策略)：用于合并两个以上分支的策略，该策略拒绝执行需要手动解决的复杂合并。 ours(合并策略参数)：可以用于任意多个分支的合并策略，合并的结果总是使用当前分支的内容而丢弃远程合并过来的版本内容 subtree(合并策略参数)：这是一个经过调整后的recursive策略 例子如下：12// 当前分支合并dev分支，有冲突完全接受dev分支的代码git merge -s recursive -x theirs dev rebase git rebase","categories":[{"name":"文档使用","slug":"文档使用","permalink":"http://yoursite.com/categories/文档使用/"}],"tags":[{"name":"Git常用命令","slug":"Git常用命令","permalink":"http://yoursite.com/tags/Git常用命令/"}]},{"title":"正则表达式","slug":"js基础-正则表达式","date":"2019-05-19T16:00:00.000Z","updated":"2019-05-22T06:30:09.000Z","comments":true,"path":"2019/05/20/js基础-正则表达式/","link":"","permalink":"http://yoursite.com/2019/05/20/js基础-正则表达式/","excerpt":"","text":"正则表达式语法123var regexp = new RegExp(pattern, modifiers)var regexp = /pattern/modifiers 需要转义的字符(使用\\转义) .(点号), ()(小括号), [](中括号), /(左斜杠), \\(右斜杠), |(选择匹配符), *, ?, {}, +, $, - 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 方括号 表达式 描述 [abc] 查找方括号之间的任何字符。 [^abc] 查找任何不在方括号之间的字符。 [0-9] 查找任何从 0 至 9 的数字。 [a-z] 查找任何从小写 a 到小写 z 的字符。 [A-Z] 查找任何从大写 A 到大写 Z 的字符。 [A-z] 查找任何从大写 A 到小写 z 的字符。 [xxx] 查找给定集合内的任何字符。 [^xxx] 查找给定集合外的任何字符。 元字符 表达式 描述 . 匹配出”\\n”(换行符)之外的任何单个字符 \\w 匹配包括下划线的任何字母,数字,下划线字符,还可以使用[0-9a-zA-Z_] \\W 匹配任何非字母,数字,下划线字符,还可以使用[^\\w] \\d 匹配一个数字字符,与使用[0-9]等价 \\D 匹配一个非数字字符,还可使用[^0-9] \\s 匹配任何空白字符 \\S 匹配任何非空白字符，还可使用[^\\s] [\\u4e00-\\u9fa5] 匹配中文字符 \\n，\\r，\\f，\\t，\\v 匹配换行符, 回车符, 换页符, 制表符, 垂直制表符 \\b 匹配单词边界 \\B 匹配非单词边界 \\xxx 查找以八进制数 xxx 规定的字符。 \\xdd 查找以十六进制数 dd 规定的字符。 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符。 量词 表达式 描述 * 匹配前面的子表达式0次或多次 (0或1) + 匹配前面的子表达式1次或多次 (1或多) ? 匹配前面的子表达式0次或1次 (0或1) {n} 匹配确定n次 {n,} 至少匹配n次 {n,m} 最少匹配n次，最多匹配m次 ^x 匹配任何开头为x的字符串 x$ 匹配任何结尾为x的字符串 贪婪和惰性模式 贪婪匹配：正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab.*c)。 惰性匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab.*c)。 贪婪模式的量词: *, +, ?, {n}, {n,}, {n,m} 惰性模式的量词: *?, +?, ??, {n}?, {n,}?, {n,m}? 分组在正则表达式中用（）包起来的内容代表了一个分组，像这样的：123var reg = /(\\d&#123;2&#125;)/reg.test('12'); // true// 这里reg中的(/d&#123;2&#125;)就表示一个分组，匹配两位数字 分组类型 捕获型 () 非捕获型 (?:) 正向前瞻性 (?=) 反向前瞻性 (?!)我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串 分组的应用 捕获型与引用($1~$n) 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串： 1234567var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/var dateStr = '2019-05-20'reg.test(dateStr) // trueRegExp.$1 // 2019RegExp.$2 // 05RegExp.$3 // 20RegExp.$4 // \"\" 反向引用(\\1~\\n) 正则表达式里也能进行引用，这称为反向引用： 12345678910var reg = /(\\w&#123;3&#125;) is \\1/reg.test('kid is kig') // truereg.test('dik is dik') // truereg.test('kid is dik') // falsreg.test('dik is kid') // false// todo 如果引用越界或者不存在的编号，就被解析为普通的表达式var reg = /(\\w&#123;3&#125;) is \\6/reg.test('kid is kid') // falsereg.test('kid is \\6') // true 非捕获型分组 使用分组并且不要捕获(即分组后不能是$1-$n去获取),使用?:,例如： 12345var reg = /(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/var date = '2019-05-20'reg.test(date)RegExp.$1 // 05RegExp.$2 // 20 正向前瞻性分组 (?=patter),匹配字符后紧跟patter返回true,否则为false 123var reg = /kid is a (?=doubi)/reg.test('kid is a doubi') // truereg.test('kid is a shabi') // true 反向前瞻型分组 (?!patter),匹配字符后不紧跟patter返回true,否则为false 123var reg = /kid is a (?!doubi)/reg.test('kid is a doubi') // falsereg.test('kid is a shabi') // true 非捕获型和(正向前瞻,反向前瞻)区别 非捕获型和(正向前瞻,反向前瞻)都不会捕获 12345678910var regvar str = 'kid is a doubi'reg = /(kid is a (?:doubi))/reg.test(str)RegExp.$1 // kid is a doubireg = /(kid is a (?=doubi))/reg = /(kid is a (?!doubi))/reg.test(str)RegExp.$1 // kid is a 也就是说非捕获型分组匹配到的字符串任然会被外层分组匹配到，而前瞻型不会，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。 正则方法 RegExp 对象方法 方法 描述 exec 检索字符串中指定的值。返回找到的值，并确定其位置。 test 检索字符串中指定的值。返回 true 或 false。 toString 返回正则表达式的字符串。 正则表达式String对象的方法 方法 描述 search 检索与正则表达式相匹配的值。 match 找到一个或多个正则表达式的匹配。 replace 替换与正则表达式匹配的子串。 split 把字符串分割为字符串数组。 RegExp 对象属性 方法 描述 constructor 返回一个函数，该函数是一个创建 RegExp 对象的原型。 global 判断是否设置了 “g” 修饰符 ignoreCase 判断是否设置了 “i” 修饰符 multiline 判断是否设置了 “m” 修饰符 source 返回正则表达式的匹配模式 lastIndex 用于规定下次匹配的起始位置 1234567891011121314151617181920例子：sourcevar patt = /ani/gpatt.test('This is a ani')console.log(patt.source) // ani例子：lastIndexvar patt = /ani/gconsole.log(patt.lastIndex) // 0patt.test('This is a ani') // trueconsole.log(patt.lastIndex) // 13// 因为当前的lastIndex(匹配其实位置为13,所以从第13位开始查找,匹配不到默认重置为0)patt.test('This is a ani') // falseconsole.log(patt.lastIndex) // 0patt.test('This is is is is is a ani') // true解决方法：在匹配前重置lastIndex: patt.lastIndex = 0 patt.test('This is a ani') // true不要使用定义的变量缓存正则表达式： /ani/g.test('This is a ani')","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://yoursite.com/categories/javascript基础/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"js性能优化","slug":"js基础-性能优化","date":"2019-05-19T16:00:00.000Z","updated":"2019-06-27T09:22:02.240Z","comments":true,"path":"2019/05/20/js基础-性能优化/","link":"","permalink":"http://yoursite.com/2019/05/20/js基础-性能优化/","excerpt":"","text":"1.加载和执行1.1 script脚本加载的三种方式 defer,async属性添加到内嵌的script脚本上是无效的,因为script标签本身就不需要异步加载了,是同步代码 defer属性 1234&lt;script defer src=\"1.js\"&gt;&lt;/script&gt;&lt;!-- defer为延迟加载脚本属性,该属性特点 --&gt;1.添加defer的script标签,不会阻塞当前DOM的加载和解析,会与其并行加载2.加载完成会在DOM加载和解析完成之后，在DOMContentLoaded事件触发之前执行脚本 async属性 1234&lt;script async src=\"2.js\"&gt;&lt;/script&gt;&lt;!-- async为异步加载脚本属性,该属性特点 --&gt;1.添加defer的script标签,不会阻塞当前DOM的加载和解析,会与其并行加载2.异步加载完脚本,即立马执行脚本内容(如比DOM加载快,会阻塞当前DOM执行) 动态创建script标签 123456789let script = document.createElement('script')script.type = 'text/javascript'script.src = 'file.js'script.onload = function () &#123; console.log('加载file.js完成')&#125;// 动态创建script标签属于异步加载(类似于async属性)1.动态创建script标签,不会阻塞当前DOM的加载和解析,会与其并行加载2.异步加载完脚本,即立马执行脚本内容(如比DOM加载快,会阻塞当前DOM执行) 1.2 优化点 闭合标签之前,将所有的&lt;script&gt;标签放到页面底部,这能确保在脚本执行前页面已经完成了渲染 合并脚本,页面中的&lt;script&gt;标签越少,加载也就越快,响应也更迅速,无论外链文件还是内嵌脚本都是如此 &lt;script&gt;标签使用defer,async属性,或者动态创建&lt;script&gt;元素","categories":[{"name":"javascript基础","slug":"javascript基础","permalink":"http://yoursite.com/categories/javascript基础/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"markdowm使用文档","slug":"文档使用-markdowm文档","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-20T03:29:49.000Z","comments":true,"path":"2019/05/11/文档使用-markdowm文档/","link":"","permalink":"http://yoursite.com/2019/05/11/文档使用-markdowm文档/","excerpt":"","text":"欢迎使用马克飞象@(示例笔记本)[马克飞象|帮助|Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Cmd + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Cmd + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Cmd + /同步文档 Cmd + S创建文档 Cmd + Opt + N最大化编辑器 Cmd + Enter预览文档 Cmd + Opt + Enter文档管理 Cmd + O系统菜单 Cmd + M 加粗 Cmd + B插入图片 Cmd + G插入链接 Cmd + L提升标题 Cmd + H 关于收费马克飞象为新用户提供 10 天的试用期，试用期过后需要续费才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#117;&#x73;&#x74;&#x67;&#x6f;&#x63;&#107;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[{"name":"文档使用","slug":"文档使用","permalink":"http://yoursite.com/categories/文档使用/"}],"tags":[{"name":"markdowm","slug":"markdowm","permalink":"http://yoursite.com/tags/markdowm/"}]},{"title":"js基础题","slug":"面试-js基础题","date":"2018-04-29T16:00:00.000Z","updated":"2019-07-19T02:31:48.048Z","comments":true,"path":"2018/04/30/面试-js基础题/","link":"","permalink":"http://yoursite.com/2018/04/30/面试-js基础题/","excerpt":"","text":"","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"js面试题","slug":"js面试题","permalink":"http://yoursite.com/tags/js面试题/"}]},{"title":"进程与线程","slug":"网络-进程与线程简单解释","date":"2018-04-29T16:00:00.000Z","updated":"2019-06-24T02:46:28.911Z","comments":true,"path":"2018/04/30/网络-进程与线程简单解释/","link":"","permalink":"http://yoursite.com/2018/04/30/网络-进程与线程简单解释/","excerpt":"","text":"","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"web其他","slug":"web其他","permalink":"http://yoursite.com/tags/web其他/"}]},{"title":"css基础","slug":"面试-css","date":"2018-04-29T16:00:00.000Z","updated":"2019-05-20T03:34:44.000Z","comments":true,"path":"2018/04/30/面试-css/","link":"","permalink":"http://yoursite.com/2018/04/30/面试-css/","excerpt":"","text":"","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"css面试题","slug":"css面试题","permalink":"http://yoursite.com/tags/css面试题/"}]},{"title":"js原理题","slug":"面试-js原理题","date":"2018-04-29T16:00:00.000Z","updated":"2019-07-19T07:35:51.423Z","comments":true,"path":"2018/04/30/面试-js原理题/","link":"","permalink":"http://yoursite.com/2018/04/30/面试-js原理题/","excerpt":"","text":"前言本文针对目前常见的面试题，仅提供了相应的核心原理及思路，部分边界细节未处理。后续会持续更新，希望对你有所帮助。 1. 实现一个call函数123456789101112// 思路：将要改变this指向的方法挂到目标this上执行并返回Function.prototype.mycall = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result&#125; 2. 实现一个apply函数12345678910111213141516// 思路：将要改变this指向的方法挂到目标this上执行并返回Function.prototype.myapply = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; 3. 实现一个bind函数12345678910111213141516// 思路：类似call，但返回的是函数Function.prototype.mybind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; let _this = this let arg = [...arguments].slice(1) return function F() &#123; // 处理函数使用new的情况 if (this instanceof F) &#123; return new _this(...arg, ...arguments) &#125; else &#123; return _this.apply(context, arg.concat(...arguments)) &#125; &#125;&#125; 4. instanceof的原理1234567891011121314// 思路：右边变量的原型存在于左边变量的原型链上function instanceOf(left, right) &#123; let leftValue = left.__proto__ let rightValue = right.prototype while (true) &#123; if (leftValue === null) &#123; return false &#125; if (leftValue === rightValue) &#123; return true &#125; leftValue = leftValue.__proto__ &#125;&#125; 5. Object.create的基本实现原理12345// 思路：将传入的对象作为原型function create(obj) &#123; function F() &#123;&#125; F.prototype = obj return new F() 6. new本质123456789101112131415161718function myNew (fun) &#123; return function () &#123; // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = &#123; __proto__ : fun.prototype &#125; // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj &#125;&#125;function person(name, age) &#123; this.name = name this.age = age&#125;let obj = myNew(person)('chen', 18) // &#123;name: \"chen\", age: 18&#125; 7. 实现一个基本的Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 未添加异步处理等其他边界情况// ①自动执行函数，②三个状态，③thenconst [ PENDING, FULFILLED, REJECTED ] = ['pending', 'fulfilled', 'rejected']const isFunction = variable =&gt; typeof variable === 'function'class Promise &#123; constructor (handle) &#123; !isFunction(handle) &amp;&amp; throw new Error('promise must accept a function paramter') this._value = undefined this._status = PENDING this._resolveQueues = [] this._rejectQueues = [] try &#123; handle(this._resolve.bind(this), this._reject.bind(this)) &#125; catch (err) &#123; this._reject(err) &#125; &#125; _resolve (value) &#123; if (this._status !== PENDING) return const runResolved = (val) =&gt; &#123; let cb while (cb = this._resolveQueues.shift()) &#123; cb(val) &#125; &#125; const runRejected = (val) =&gt; &#123; let cb while (cb = this._rejecteQueues.shift()) &#123; cb(val) &#125; &#125; if (value instanceof Promise) &#123; value.then(res =&gt; &#123; this._value = res this._status = FULFILLED runResolved(this._value) &#125;, rej =&gt; &#123; this._value = rej this._status = REJECTED runRejected(this_value) &#125;) &#125; else &#123; this._value = value this._status = FULFILLED runResolved(this._value) &#125; &#125; _reject (value) &#123; if (this._status !== PENDING) return let cb this._value = value this._status = REJECTED while (cb = this._rejectQueues.shift()) &#123; cb(this._value) &#125; &#125; then (onResolve, onReject) &#123; const &#123; _value, _status &#125; = this return new Promise((onResolveNext, onRejectNext) =&gt; &#123; const resolved = (val) =&gt; &#123; try &#123; if (!isFunction(onResolve)) &#123; onResolveNext(val) &#125; else &#123; let res = onResolve(val) if (res instanceof Promise) &#123; res.then(onResolveNext, onRejectNext) &#125; else &#123; onResolveNext(res) &#125; &#125; &#125; catch (err) &#123; onRejectNext(err) &#125; &#125; const rejected = (val) =&gt; &#123; try &#123; if (!isFunction(onReject)) &#123; onRejectNext(val) &#125; else &#123; let res = onRejected(val) if (res instanceof Promise) &#123; res.then(onResolveNext, onRejectNext) &#125; else &#123; onResolveNext(res) &#125; &#125; &#125; catch (err) &#123; onRejectNext(err) &#125; &#125; switch (_status) &#123; case PENDING: this._resolveQueues.push(resolved) this._rejectQueues.push(rejected) break case FULFILLED: resolved(_value) break case REJECTED: rejected(_value) break &#125; &#125;) &#125; static resolve (val) &#123; if (val instanceof Promise) return val return new Promise(resolve =&gt; resolve(val)) &#125; static reject (val) &#123; return new Promise(null, reject =&gt; reject(val)) &#125; static race (list) &#123; return new Promise((resolve, reject) =&gt; &#123; for (let p of list) &#123; p.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; reject(rej) &#125;) &#125; &#125;) &#125; static all (list) &#123; return new Promise((resolve, reject) =&gt; &#123; let [ i, arr ] = [ 0, [] ] for (let p of list) &#123; p.then(res =&gt; &#123; i++ arr.push(res) (list.length === i) &amp;&amp; resolve(arr) &#125;, rej =&gt; &#123; reject(rej) &#125;) &#125; &#125;) &#125; finally (callback) &#123; return this.then( res =&gt; Promise.resolve(callback()).then(() =&gt; res), rej =&gt; Promise.resolve(callback()).then() =&gt; throw rej) ) &#125;&#125; 8. 实现浅拷贝123456// 1. ...实现let copy1 = &#123;...&#123;x:1&#125;&#125;// 2. Object.assign实现let copy2 = Object.assign(&#123;&#125;, &#123;x:1&#125;) 9. 实现一个基本的深拷贝1234567891011121314// 1. JOSN.stringify()/JSON.parse()let obj = &#123;a: 1, b: &#123;x: 3&#125;&#125;JSON.parse(JSON.stringify(obj))// 2. 递归拷贝function deepClone(obj) &#123; let copy = obj instanceof Array ? [] : &#123;&#125; for (let i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i] &#125; &#125; return copy&#125; 10. 使用setTimeout模拟setInterval12345// 可避免setInterval因执行时间导致的间隔执行时间不一致setTimeout (function () &#123; // do something setTimeout (arguments.callee, 500)&#125;, 500) 11. js实现一个继承方法12345678910// 借用构造函数继承实例属性function Child () &#123; Parent.call(this)&#125;// 寄生继承原型属性(function () &#123; let Super = function () &#123;&#125; Super.prototype = Parent.prototype Child.prototype = new Super()&#125;)() 12. 实现一个基本的Event Bus123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener('ages', age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit('ages', 18) // 18 13. 实现一个双向数据绑定123456789101112131415161718192021let obj = &#123;&#125;let input = document.getElementById('input')let span = document.getElementById('span')// 数据劫持Object.defineProperty(obj, 'text', &#123; configurable: true, enumerable: true, get() &#123; console.log('获取数据了') return obj['text'] &#125;, set(newVal) &#123; console.log('数据更新了') input.value = newVal span.innerHTML = newVal &#125;&#125;)// 输入监听input.addEventListener('keyup', function(e) &#123; obj.text = e.target.value&#125;) 完整实现可前往之前写的：这应该是最详细的响应式系统讲解了 14. 实现一个简单路由1234567891011121314151617181920212223// hash路由class Route&#123; constructor()&#123; // 路由存储对象 this.routes = &#123;&#125; // 当前hash this.currentHash = '' // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener('load', this.freshRoute, false) window.addEventListener('hashchange', this.freshRoute, false) &#125; // 存储 storeRoute (path, cb) &#123; this.routes[path] = cb || function () &#123;&#125; &#125; // 更新 freshRoute () &#123; this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() &#125; &#125; 15. 实现懒加载123456789101112&lt;ul&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/1.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/2.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/3.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/4.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/5.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/6.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/7.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/8.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/9.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./imgs/default.png\" data=\"./imgs/10.png\" alt=\"\"&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516let imgs = document.querySelectorAll('img')// 可视区高度let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeightfunction lazyLoad () &#123; // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i &lt; imgs.length; i ++) &#123; // 得到图片顶部距离可视区顶部的距离 let x = clientHeight + scrollTop - imgs[i].offsetTop // 图片在可视区内 if (x &gt; 0 &amp;&amp; x &lt; clientHeight+imgs[i].height) &#123; imgs[i].src = imgs[i].getAttribute('data') &#125; &#125; &#125;// addEventListener('scroll', lazyLoad) or setInterval(lazyLoad, 1000) 16. rem基本设置12345678910// 原始配置function setRem () &#123; let doc = document.documentElement let width = doc.getBoundingClientRect().width // 假设设计稿为宽750，则1rem代表10px let rem = width / 75 doc.style.fontSize = rem + 'px'&#125;// 监听窗口变化addEventListener(\"resize\", setRem) 17. 手写实现AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 1. 简单流程// 实例化let xhr = new XMLHttpRequest()// 初始化xhr.open(method, url, async)// 发送请求xhr.send(data)// 设置状态变化回调处理请求结果xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyStatus === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText) &#125;&#125;// 2. 基于promise实现 function ajax (options) &#123; // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || 'get' // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout &amp;&amp; options.timeout &gt; 0) &#123; xhr.timeout = options.timeout &#125; // 返回一个Promise实例 return new Promise ((resolve, reject) =&gt; &#123; xhr.ontimeout = () =&gt; reject &amp;&amp; reject('请求超时') // 监听状态变化回调 xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState == 4) &#123; // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; resolve &amp;&amp; resolve(xhr.responseText) &#125; else &#123; reject &amp;&amp; reject() &#125; &#125; &#125; // 错误回调 xhr.onerror = err =&gt; reject &amp;&amp; reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) &#123; for (let key in data) &#123; // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])) &#125; encodeData = paramArr.join('&amp;') &#125; // get请求拼接参数 if (method === 'get') &#123; // 检测url中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&amp;' // 拼接url url += encodeData &#125; // 初始化 xhr.open(method, url, async) // 发送请求 if (method === 'get') xhr.send(null) else &#123; // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) &#125; &#125;)&#125; 18. 实现拖拽1234567891011121314151617181920212223242526272829303132window.onload = function () &#123; // drag处于绝对定位状态 let drag = document.getElementById('box') drag.onmousedown = function(e) &#123; var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) &#123; // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left &lt; 0) &#123; left = 0 &#125; else if (left &gt; window.innerWidth - drag.offsetWidth) &#123; left = window.innerWidth - drag.offsetWidth &#125; if (top &lt; 0) &#123; top = 0 &#125; else if (top &gt; window.innerHeight - drag.offsetHeight) &#123; top = window.innerHeight - drag.offsetHeight &#125; drag.style.left = left + 'px' drag.style.top = top + 'px' &#125; drag.onmouseup = function (e) &#123; this.onmousemove = null this.onmouseup = null &#125; &#125;&#125; 19. 实现一个节流函数12345678910111213141516171819// 思路：在规定时间内只触发一次function throttle (fn, delay) &#123; // 利用闭包保存时间 let prev = Date.now() return function () &#123; let context = this let arg = arguments let now = Date.now() if (now - prev &gt;= delay) &#123; fn.apply(context, arg) prev = Date.now() &#125; &#125;&#125;function fn () &#123; console.log('节流')&#125;addEventListener('scroll', throttle(fn, 1000)) 20. 实现一个防抖函数12345678910111213141516171819// 思路:在规定时间内未触发第二次，则执行function debounce (fn, delay) &#123; // 利用闭包保存定时器 let timer = null return function () &#123; let context = this let arg = arguments // 在规定时间内再次触发会先清除定时器后再重设定时器 clearTimeout(timer) timer = setTimeout(function () &#123; fn.apply(context, arg) &#125;, delay) &#125;&#125;function fn () &#123; console.log('防抖')&#125;addEventListener('scroll', debounce(fn, 1000))","categories":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://yoursite.com/categories/前端面试题/"}],"tags":[{"name":"js面试题","slug":"js面试题","permalink":"http://yoursite.com/tags/js面试题/"}]},{"title":"web安全类","slug":"网络-web安全","date":"2018-04-29T16:00:00.000Z","updated":"2019-06-24T02:42:36.390Z","comments":true,"path":"2018/04/30/网络-web安全/","link":"","permalink":"http://yoursite.com/2018/04/30/网络-web安全/","excerpt":"","text":"XSS攻击XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。 XSS分类 根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击： 反射型XSS当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。 反射型XSS的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 如何防范反射型XSS攻击 对字符串进行编码。 对url的查询参数进行转义后再输出到页面。 1234app.get('/welcome', function(req, res) &#123; //对查询参数进行编码，避免反射型 XSS攻击 res.send(`$&#123;encodeURIComponent(req.query.type)&#125;`); &#125;); DOM型XSSDOM 型 XSS 攻击，实际上就是前端 JavaScript 代码不够严谨，把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等。 DOM 型 XSS 的攻击步骤： 1.攻击者构造出特殊数据，其中包含恶意代码。2.用户浏览器执行了恶意代码。3.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 如何防范 DOM 型 XSS 攻击 防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。 1.对于url链接(例如图片的src属性)，那么直接使用 encodeURIComponent 来转义。 2.非url，我们可以这样进行编码： 123456function encodeHtml(str) &#123; return str.replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;apos;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;');&#125; DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。 存储型XSS恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。 存储型 XSS 的攻击步骤： 1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 如何防范存储型XSS攻击： 1.前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)2.服务器接收到数据，在存储到数据库之前，进行转义/过滤3.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤 XSS其他防范手段1.Content Security Policy 在服务端使用 HTTP的 Content-Security-Policy 头部来指定策略，或者在前端设置 meta 标签。 例如下面的配置只允许加载同域下的资源： 1Content-Security-Policy: default-src 'self' 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"form-action 'self';\"&gt; 前端和服务端设置 CSP 的效果相同，但是meta无法使用report 严格的 CSP 在 XSS 的防范中可以起到以下的作用： 1.禁止加载外域代码，防止复杂的攻击逻辑。2.禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。3.禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。4.禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。5.合理使用上报可以及时发现 XSS，利于尽快修复问题。 2.输入内容长度控制 对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 3.输入内容限制 对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。 4.其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 XSS检测1.使用通用 XSS 攻击字串手动检测 XSS 漏洞 1如: javascript:/*-/*`/*\\`/*&apos;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e 能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。 1&lt;img src=1 onerror=alert(1)&gt; 2.使用第三方工具进行扫描 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 典型的CSRF攻击流程： 1.受害者登录A站点，并保留了登录凭证（Cookie）。2.攻击者诱导受害者访问了站点B。3.站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。4.站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。5.站点A以受害者的名义执行了站点B的请求。6.攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。 CSRF的特点 1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击) CSRF 攻击防御 添加验证码(体验不好)验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。 判断请求的来源：检测Referer(并不安全，Referer可以被更改)Referer 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 Referer 本身是可以被修改的，因为不能仅依赖于 Referer 使用Token(主流)CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。 服务端给用户生成一个token，加密后传递给用户 用户在提交请求时，需要携带这个token 服务端验证token是否正确 Samesite Cookie属性为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。Samesite=StrictSamesite=Strict 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。 123**Samesite=Lax**`Samesite=Lax` 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 `Get` / `OPTIONS` 、`HEAD` 请求.但是不安全 HTTP 方法，如： `POST`, `PUT`, `DELETE` 请求时，不能作为第三方链接的 Cookie 为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。 点击劫持点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。 典型点击劫持攻击流程1.攻击者构建了一个非常有吸引力的网页【不知道哪些内容对你们来说有吸引力，我就不写页面了，偷个懒】2.将被攻击的页面放置在当前页面的 iframe 中3.使用样式将 iframe 叠加到非常有吸引力内容的上方4.将iframe设置为100%透明5.你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。 点击劫持防御1.frame busting123if ( top.location != window.location )&#123; top.location = window.location&#125; 需要注意的是: HTML5中iframe的 sandbox 属性、IE中iframe的security 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。 X-Frame-Options X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。 可以设置为以下值: DENY: 拒绝任何域加载 SAMEORIGIN: 允许同源域下加载 ALLOW-FROM: 可以定义允许frame加载的页面地址 安全扫描工具1.Arachni Arachni是基于Ruby的开源，功能全面，高性能的漏洞扫描框架，Arachni提供简单快捷的扫描方式，只需要输入目标网站的网址即可开始扫描。它可以通过分析在扫描过程中获得的信息，来评估漏洞识别的准确性和避免误判。Arachni默认集成大量的检测工具，可以实施 代码注入、CSRF、文件包含检测、SQL注入、命令行注入、路径遍历等各种攻击。同时，它还提供了各种插件，可以实现表单爆破、HTTP爆破、防火墙探测等功能。针对大型网站，该工具支持会话保持、浏览器集群、快照等功能，帮助用户更好实施渗透测试 2.Mozilla HTTP Observatory Mozilla HTTP Observatory，是Mozilla最近发布的一款名为Observatory的网站安全分析工具，意在鼓励开发者和系统管理员增强自己网站的安全配置。用法非常简单：输入网站URL，即可访问并分析网站HTTP标头，随后可针对网站安全性提供数字形式的分数和字母代表的安全级别。 Cookie 跨源资源共享（CORS） 内容安全策略（CSP） HTTP公钥固定（Public Key Pinning） HTTP严格安全传输（HSTS）状态 是否存在HTTP到HTTPs的自动重定向 子资源完整性（Subresource Integrity） X-Frame-Options X-XSS-Protection 3. w3af W3af是一个基于Python的Web应用安全扫描器。可帮助开发人员，有助于开发人员和测试人员识别Web应用程序中的漏洞。扫描器能够识别200多个漏洞，包括跨站点脚本、SQL注入和操作系统命令。","categories":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/categories/网络/"}],"tags":[{"name":"web其他","slug":"web其他","permalink":"http://yoursite.com/tags/web其他/"}]}]}