<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EvanYang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-05T09:08:55.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Evan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iconfont优雅使用</title>
    <link href="http://yoursite.com/2019/06/05/%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8-icon%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/06/05/文档使用-icon优雅使用/</id>
    <published>2019-06-05T07:26:11.000Z</published>
    <updated>2019-06-05T09:08:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="演进史"><a href="#演进史" class="headerlink" title="演进史"></a>演进史</h2><p>首先我们来说一下前端 icon 的发展史。</p><p><strong>远古时代</strong><br>在我刚开始实习时，大部分图标都是用 img 来实现的。渐渐发现一个页面的请求资源中图片 img 占了大部分，所以为了优化有了<code>image sprite</code> 就是所谓的雪碧图，就是将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。但这个也有一个很大的痛点，维护困难。每新增一个图标，都需要改动原始图片，还可能不小心出错影响到前面定位好的图片，而且一修改雪碧图，图片缓存就失效了，久而久之你不知道该怎么维护了。</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/11/28/16000934d9f88e9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><p><strong>font 库</strong><br>后来渐渐地一个项目里几乎不会使用任何本地的图片了，而使用一些 font 库来实现页面图标。常见的如 <a href="https://link.juejin.im?target=http%3A%2F%2Ffontawesome.io%2F" target="_blank" rel="noopener">Font Awesome</a> ，使用起来也非常的方便，但它有一个致命的缺点就是找起来真的很不方便，每次找一个图标特别的费眼睛，还有就是它的定制性也非常的不友善，它的图标库一共有675个图标，说少也不少，但还是会常常出现找不到你所需要图标的情况。当然对于没有啥特别 ui 追求的初创公司来说还是能忍一忍的。但随着公司的壮大，来了越来越多对前端指手画脚的人，丧心病狂的设计师，他们会说不！这icon这么丑，这简直是在侮辱他们高级设计师的称号啊！不过好在这时候有了<a href="https://link.juejin.im?target=http%3A%2F%2Ficonfont.cn%2F" target="_blank" rel="noopener">iconfont</a> 。</p><p><strong>iconfont</strong><br>一个阿里爸爸做的开源图库，人家还有专门的 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fthx%2Ficonfont-plus%2Fissues" target="_blank" rel="noopener">github issue</a>(虽然我的一个 issue 半年多了也没回应/(ㄒoㄒ)/~~)，但人家的图标数量还是很惊人的，不仅有几百个公司的开源图标库，还有各式各样的小图标，还支持自定义创建图标库，所以不管你是一家创业公司还是对设计很有要求的公司，它都能很好的帮助你解决管理图标的痛点。你想要的基本都有~</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/10/19/92e198653125f31275907d20f9322dbc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><h2 id="iconfont-三种使用姿势"><a href="#iconfont-三种使用姿势" class="headerlink" title="iconfont 三种使用姿势"></a>iconfont 三种使用姿势</h2><h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><p>最开始我们使用了<code>unicode</code>的格式，它主要的特点是<br><strong>优势</strong></p><ul><li>兼容性最好，支持ie6+</li><li>支持按字体的方式去动态调整图标大小，颜色等等</li></ul><p><strong>劣势</strong></p><ul><li>不支持多色图标</li><li>在不同的设备浏览器字体的渲染会略有差别，在不同的浏览器或系统中对文字的渲染不同，其显示的位置和大小可能会受到font-size、line-height、word-spacing等CSS属性的影响，而且这种影响调整起来较为困难</li></ul><p><strong>使用方法：</strong><br>第一步：引入自定义字体 `font-face</p><pre><code> @font-face {   font-family: &lt;span class=&quot;hljs-string&quot;&gt;&quot;iconfont&quot;&lt;/span&gt;;   src: url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.eot&apos;&lt;/span&gt;); /* IE9*/   src: url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.eot#iefix&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;embedded-opentype&apos;&lt;/span&gt;), /* IE6-IE8 */   url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.woff&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;woff&apos;&lt;/span&gt;), /* chrome, firefox */   url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.ttf&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;truetype&apos;&lt;/span&gt;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/   url(&lt;span class=&quot;hljs-string&quot;&gt;&apos;iconfont.svg#iconfont&apos;&lt;/span&gt;) format(&lt;span class=&quot;hljs-string&quot;&gt;&apos;svg&apos;&lt;/span&gt;); /* iOS 4.1- */ }&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;`&lt;/pre&gt;第二步：定义使用iconfont的样式&lt;pre&gt;`.iconfont {  font-family:&lt;span class=&quot;hljs-string&quot;&gt;&quot;iconfont&quot;&lt;/span&gt; !important;  font-size:16px;  font-style:normal;  -webkit-font-smoothing: antialiased;  -webkit-text-stroke-width: 0.2px;  -moz-osx-font-smoothing: grayscale;}&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;`&lt;/pre&gt;第三步：挑选相应图标并获取字体编码，应用于页面&lt;pre&gt;`&amp;lt;i class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;iconfont&quot;&lt;/span&gt;&amp;gt;&amp;amp;&lt;span class=&quot;hljs-comment&quot;&gt;#xe604;&amp;lt;/i&amp;gt;&lt;/span&gt;&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;`&lt;/pre&gt;效果图：&lt;figure&gt;{% image https://user-gold-cdn.xitu.io/2017/10/19/212123363f183d2984e314cc89b9e113?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 '' '' %}&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;其实它的原理也很简单，就是通过 `@font-face` 引入自定义字体(其实就是一个字体库)，它里面规定了`&amp;amp;#xe604` 这个对应的形状就长这企鹅样。其实类似于 &apos;花裤衩&apos;，在不同字体设定下长得是不同的一样。&lt;figure&gt;{% image https://user-gold-cdn.xitu.io/2017/10/19/d142cf85062436fadef23bae4e3eafb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 '' '' %}&lt;figcaption&gt;&lt;/figcaption&gt;&lt;/figure&gt;不过它的缺点也显而易见，`unicode`的书写不直观，语意不明确。光看`&amp;amp;#xe604;`这个`unicode`你完全不知道它代表的是什么意思。这时候就有了 `font-class`。### font-class与unicode使用方式相比，具有如下特点：</code></pre><ul><li>兼容性良好，支持ie8+</li><li><p>相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。</p><p><strong>使用方法：</strong><br>第一步：拷贝项目下面生成的fontclass代码：</p><pre>`../font_8d5l8fzk5b87iudi.css<span class="copy-code-btn">复制代码</span>`</pre><p>第二步：挑选相应图标并获取类名，应用于页面：</p><pre>`&lt;i class=<span class="hljs-string">"iconfont icon-xxx"</span>&gt;&lt;/i&gt;<span class="copy-code-btn">复制代码</span>`</pre><p>效果图：</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/10/19/b4e0fbe350b5be037b5622ce06bf0392?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><figcaption></figcaption></figure><p>它的主要原理其实是和 <code>unicode</code> 一样的，它只是多做了一步，将原先<code>&amp;amp;#xe604</code>这种写法换成了<code>.icon-QQ</code>，它在每个 class 的 before 属性中写了<code>unicode</code>,省去了人为写的麻烦。如 <code>.icon-QQ:before { content: &quot;\e604&quot;; }</code></p><p>相对于<code>unicode</code> 它的修改更加的方便与直观。但也有一个大坑，之前楼主一个项目中用到了两组<code>font-class</code> 由于没有做好命名空间，所有的class都是放在<code>.iconfont</code> 命名空间下的，一上线引发了各种雪崩问题，修改了半天，所以使用<code>font-class</code>一定要注意命名空间的问题。</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>随着万恶的某某浏览器逐渐淡出历史舞台，svg-icon 使用形式慢慢成为主流和推荐的方法。相关文章可以参考张鑫旭大大的文章<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2014%2F07%2Fintroduce-svg-sprite-technology%2F%3Fspm%3Da313x.7781069.1998910419.50" target="_blank" rel="noopener">未来必热：SVG Sprite技术介绍</a></p></li><li><p>支持多色图标了，不再受单色限制。</p></li><li>支持像字体那样通过font-size,color来调整样式。</li><li>支持 ie9+</li><li>可利用CSS实现动画。</li><li>减少HTTP请求。</li><li>矢量，缩放不失真</li><li><p>可以很精细的控制SVG图标的每一部分</p><p><strong>使用方法：</strong><br>第一步：拷贝项目下面生成的symbol代码：</p><pre>`引入  ./iconfont.js<span class="copy-code-btn">复制代码</span>`</pre><p>第二步：加入通用css代码（引入一次就行）：</p><pre>`&lt;style type="text/css"&gt;    .icon {       width: 1em; height: 1em;       vertical-align: -0.15em;       fill: currentColor;       overflow: hidden;    }&lt;/style&gt;<span class="copy-code-btn">复制代码</span>`</pre><p>第三步：挑选相应图标并获取类名，应用于页面：</p><pre>`<span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#icon-xxx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><span class="copy-code-btn">复制代码</span>`</pre><p>使用svg-icon的好处是我再也不用发送<code>woff|eot|ttf|</code> 这些很多个字体库请求了，我所有的svg都可以内联在html内。</p><p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/10/19/9dae2c582c3d2d3d62e9b5079b82348a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><br>还有一个就是 svg 是一个真正的矢量，不管你再怎么的放缩它都不会失真模糊，而且svg可以控制的属性也更加的丰富，也能做出更加生动和复杂的图标。现在ui设计师平时都喜欢使用 sketch 来工作，只要轻松一键就能导出 svg 了，所以 svg 也更受设计师的青睐。<a href="https://link.juejin.im?target=https%3A%2F%2Fcss-tricks.com%2Ficon-fonts-vs-svg%2F" target="_blank" rel="noopener">Inline SVG vs Icon Fonts </a> 这篇文章详细的比较了 <code>svg</code> 和 <code>icon-font</code>的优劣，大家可以去看看。PS：这里其实还用到了 <code>SVG Sprite</code> 技术。简单的理解就是类 svg 的似雪碧图，它在一个 svg 之中运用 symbol 标示了一个一个的 svg 图标，这样一个页面中我们遇到同样的 svg 就不用重复再画一个了，直接使用<code>&amp;lt;use xlink:href=&quot;#icon-QQ&quot; x=&quot;50&quot; y=&quot;50&quot; /&amp;gt;</code> 就能使用了，具体的细节可以看这篇文章开头的文章 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2014%2F07%2Fintroduce-svg-sprite-technology%2F" target="_blank" rel="noopener">未来必热：SVG Sprite技术介绍</a>，在之后的文章中也会手摸手叫你自己如何制作 <code>SVG Sprite</code>。</p><h2 id="创建-icon-component-组件"><a href="#创建-icon-component-组件" class="headerlink" title="创建 icon-component 组件"></a>创建 icon-component 组件</h2><p>我们有了图标，接下来就是如何在自己的项目中优雅的使用它了。<br>之后的代码都是基于 vue 的实例(ps: react 也很简单，原理都是类似的)</p><pre>`//components/Icon-svg<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"svg-icon"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">:xlink:href</span>=<span class="hljs-string">"iconName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {  <span class="hljs-attr">name</span>: <span class="hljs-string">'icon-svg'</span>,  <span class="hljs-attr">props</span>: {    <span class="hljs-attr">iconClass</span>: {      <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>,      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>    }  },  <span class="hljs-attr">computed</span>: {    iconName() {      <span class="hljs-keyword">return</span> <span class="hljs-string">`#icon-<span class="hljs-subst">${<span class="hljs-keyword">this</span>.iconClass}</span>`</span>    }  }}</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-class">.svg-icon</span> {  <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">1em</span>;  <span class="hljs-attribute">vertical-align</span>: -<span class="hljs-number">0.15em</span>;  <span class="hljs-attribute">fill</span>: currentColor;  <span class="hljs-attribute">overflow</span>: hidden;}</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="copy-code-btn">复制代码</span>`</pre><pre>`<span class="hljs-comment">//引入svg组件</span><span class="hljs-keyword">import</span> IconSvg <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/IconSvg'</span><span class="hljs-comment">//全局注册icon-svg</span>Vue.component(<span class="hljs-string">'icon-svg'</span>, IconSvg)<span class="hljs-comment">//在代码中使用</span>&lt;icon-svg icon-<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"password"</span> /&gt;<span class="copy-code-btn">复制代码</span>`</pre><p>就这样简单封装了一个 <code>Icon-svg</code> 组件 ，我们就可以简单优雅的在自己的vue项目之中使用图标了。</p><h2 id="进一步改造"><a href="#进一步改造" class="headerlink" title="进一步改造"></a>进一步改造</h2><p>但作为一个有逼格的前端开发，怎能就此满足呢!目前还是有一个致命的缺点的，就是现在所有的 <code>svg-sprite</code> 都是通过 iconfont 的 <code>iconfont.js</code> 生成的。</p></li><li><p>首先它是一段用js来生成svg的代码，所有图标 icon 都很<strong>不直观</strong>。<br><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/10/19/2338a1978a732b5cbc3995c3b5e57300?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示" title>                </div>                <div class="image-caption">如图所示</div>            </figure><figcaption></figcaption></figure><br>你完全不知道哪个图标名对应什么图标，一脸尼克扬问号??? 每次增删改图标只能整体js文件一起替换。</p></li><li><p>其次它也做不到<strong>按需加载</strong>，不能根据我们使用了那些 svg 动态的生成 <code>svg-sprite</code>。</p></li><li><strong>自定义性差</strong>，通常导出的svg包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容。</li><li><p><strong>添加不友善</strong>，如果我有一些自定义的svg图标，该如何和原有的 <code>iconfont</code> 整合到一起呢？目前只能将其也上传到 <code>iconfont</code> 和原有的图标放在一个项目库中，之后再重新下载，很繁琐。</p><h3 id="使用-svg-sprite"><a href="#使用-svg-sprite" class="headerlink" title="使用 svg-sprite"></a>使用 svg-sprite</h3><p>接下来我们就要自己来制作 <code>svg-sprite</code> 了。这里要使用到 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkisenka%2Fsvg-sprite-loader" target="_blank" rel="noopener">svg-sprite-loader</a> 这个神器了， 它是一个 webpack loader ，可以将多个 svg 打包成 <code>svg-sprite</code> 。</p><p>我们来介绍如何在 <code>vue-cli</code> 的基础上进行改造，加入 <code>svg-sprite-loader</code>。</p><p>我们发现<code>vue-cli</code>默认情况下会使用 <code>url-loader</code> 对svg进行处理，会将它放在<code>/img</code> 目录下，所以这时候我们引入<code>svg-sprite-loader</code> 会引发一些冲突。</p><pre>`<span class="hljs-comment">//默认`vue-cli` 对svg做的处理，正则匹配后缀名为.svg的文件，匹配成功之后使用 url-loader 进行处理。</span> {    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,    <span class="hljs-attr">loader</span>: <span class="hljs-string">'url-loader'</span>,    <span class="hljs-attr">options</span>: {      <span class="hljs-attr">limit</span>: <span class="hljs-number">10000</span>,      <span class="hljs-attr">name</span>: utils.assetsPath(<span class="hljs-string">'img/[name].[hash:7].[ext]'</span>)    }}<span class="copy-code-btn">复制代码</span>`</pre><p>解决方案有两种，最简单的就是你可以将 test 的 svg 去掉，这样就不会对svg做处理了，当然这样做是很不友善的。</p></li><li><p>你不能保证你所有的 svg 都是用来当做 icon的，有些真的可能只是用来当做图片资源的。</p></li><li><p>不能确保你使用的一些第三方类库会使用到 svg。</p><p>所以最安全合理的做法是使用 webpack 的 <a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23rule-exclude" target="_blank" rel="noopener">exclude</a> 和 <a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23rule-include" target="_blank" rel="noopener">include</a> ，让<code>svg-sprite-loader</code>只处理你指定文件夹下面的 svg，<code>url-loaer</code>只处理除此文件夹之外的所以 svg，这样就完美解决了之前冲突的问题。<br>代码如下</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/10/19/28b4391b217a47ab403c659480a192ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><p>这样配置好了，只要引入svg之后填写类名就可以了</p><pre>`import '@/src/icons/qq.svg; //引入图标&lt;svg&gt;&lt;use xlink:href="#qq" /&gt;&lt;/svg&gt;  //使用图标<span class="copy-code-btn">复制代码</span>`</pre><p>单这样还是非常的不优雅，如果我项目中有一百个 icon，难不成我要手动一个个引入么！ <strong>偷懒是程序员的第一生产力！！！</strong></p><h2 id="自动导入"><a href="#自动导入" class="headerlink" title="自动导入"></a>自动导入</h2><p>首先我们创建一个专门放置图标 icon 的文件夹如：<code>@/src/icons</code>，将所有 icon 放在这个文件夹下。<br>之后我们就要使用到 webpack 的 <a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.js.org%2Fguides%2Fdependency-management%2F%23require-context" target="_blank" rel="noopener">require.context</a>。很多人对于 <code>require.context</code>可能比较陌生，直白的解释就是</p><blockquote><p>require.context(“./test”, false, /.test.js$/);</p><pre><code>这行代码就会去 test 文件夹（不包含子目录）下面的找所有文件名以 `.test.js` 结尾的文件能被 require 的文件。更直白的说就是 我们可以通过正则匹配引入相应的文件模块。</code></pre></blockquote><p>require.context有三个参数：</p></li><li><p>directory：说明需要检索的目录</p></li><li>useSubdirectories：是否检索子目录</li><li><p>regExp: 匹配文件的正则表达式</p><p>了解这些之后，我们就可以这样写来自动引入 <code>@/src/icons</code> 下面所有的图标了</p><p><pre>`<span class="hljs-keyword">const</span> requireAll = <span class="hljs-function"><span class="hljs-params">requireContext</span> =&gt;</span> requireContext.keys().map(requireContext)<br><span class="hljs-keyword">const</span> req = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">‘./svg’</span>, <span class="hljs-literal">false</span>, /.svg$/)<br>requireAll(req)<br><span class="copy-code-btn">复制代码</span></pre></p></li></ul><p>之后我们增删改图标直接直接文件夹下对应的图标就好了，什么都不用管，就会自动生成 <code>svg symbol</code>了。</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/11/27/15ffc860a0fe3fed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><h2 id="更进一步优化自己的svg"><a href="#更进一步优化自己的svg" class="headerlink" title="更进一步优化自己的svg"></a>更进一步优化自己的svg</h2><p>首先我们来看一下 从 <code>阿里iconfont</code> 网站上导出的 svg 长什么样？</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/11/27/15ffcbc9289b7613?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><p>没错虽然 iconfont 网站导出的 svg 内容已经算蛮精简的了，但你会发现其实还是与很多无用的信息，造成了不必要的冗余。就连 iconfont 网站导出的 svg 都这样，更不用说那些更在意 ui漂不漂亮不懂技术的设计师了(可能)导出的svg了。好在 <code>svg-sprite-loader</code>也考虑到了这点，它目前只会获取 svg 中 path 的内容，而其它的信息一概不会获取。生成 svg 如下图：</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/11/27/15ffcc7231fc7aed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><p>但任何你在 path 中产生的冗余信息它就不会做处理了。如注释什么的</p><figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2017/11/27/15ffcc9535745d8d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><figcaption></figcaption></figure><p>这时候我们就要使用另一个很好用的东西了– <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsvg%2Fsvgo" target="_blank" rel="noopener">svgo</a></p><blockquote><p>SVG files, especially exported from various editors, usually contain a lot of redundant and useless information such as editor metadata, comments, hidden elements, default or non-optimal values and other stuff that can be safely removed or converted without affecting SVG rendering result.</p></blockquote><p>它支持几十种优化项，非常的强大，8k+的star 也足以说明了问题。</p><p>详细的操作可以参照 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fsvg%2Fsvgo" target="_blank" rel="noopener">官方文档</a> <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2016%2F02%2Fsvg-compress-tool-svgo-experience%2F" target="_blank" rel="noopener">张鑫旭大大的文章</a>（没错又是这位大大的文章，或许这就是大佬吧！）本文就不展开了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面大概阐述了一下前端项目中 icon 使用的演进史。<br>总的来说还是那句话，<strong>适合的才是最好的</strong>。就拿之前争论的选择 vue react 还是 angular，个人觉得每个框架都有自己的特点和适用的业务场景，所以所有不结合业务场景的推荐和讨论都是瞎bb。。。如上文其实大概讲了五种前端icon的使用场景，第一种<code>Font Awesome</code>不用它并不是因为它不好，而是业务场景不适合，如果你团队没有专门的设计师或者对 icon 的自定义度不高完全可以使用它，<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FFortAwesome%2FFont-Awesome" target="_blank" rel="noopener">Font Awesome</a> github有五万多 star，足见社区对它的认可。还比如说，你们项目对低端浏览器有较高的适配要求，你还强行要用 svg 作为图标 icon，那你真的是存心和自己过不去了。所以所有方案都没有绝对的优与劣之分，适合自己业务场景，解决自己实际痛点，提高自己开发效率的方案就是好的方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;演进史&quot;&gt;&lt;a href=&quot;#演进史&quot; class=&quot;headerlink&quot; title=&quot;演进史&quot;&gt;&lt;/a&gt;演进史&lt;/h2&gt;&lt;p&gt;首先我们来说一下前端 icon 的发展史。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远古时代&lt;/strong&gt;&lt;br&gt;在我刚开始实习时，大部分
      
    
    </summary>
    
      <category term="文档使用" scheme="http://yoursite.com/categories/%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="iconfont" scheme="http://yoursite.com/tags/iconfont/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2019/05/20/js%E5%9F%BA%E7%A1%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/05/20/js基础-正则表达式/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-22T06:30:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern, modifiers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/pattern/m</span>odifiers</span><br></pre></td></tr></table></figure><p><strong>需要转义的字符</strong>(使用<code>\</code>转义)</p><p><code>.</code>(点号), <code>()</code>(小括号), <code>[]</code>(中括号), <code>/</code>(左斜杠), <code>\</code>(右斜杠), <code>|</code>(选择匹配符), <code>*</code>, <code>?</code>, <code>{}</code>, <code>+</code>, <code>$</code>, <code>-</code></p><hr><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table><thead><tr><th style="text-align:left">修饰符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">i</td><td style="text-align:left">执行对大小写不敏感的匹配。</td></tr><tr><td style="text-align:left">g</td><td style="text-align:left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td style="text-align:left">m</td><td style="text-align:left">执行多行匹配。</td></tr></tbody></table><h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[abc]</td><td style="text-align:left">查找方括号之间的任何字符。</td></tr><tr><td style="text-align:left">[^abc]</td><td style="text-align:left">查找任何不在方括号之间的字符。</td></tr><tr><td style="text-align:left">[0-9]</td><td style="text-align:left">查找任何从 0 至 9 的数字。</td></tr><tr><td style="text-align:left">[a-z]</td><td style="text-align:left">查找任何从小写 a 到小写 z 的字符。</td></tr><tr><td style="text-align:left">[A-Z]</td><td style="text-align:left">查找任何从大写 A 到大写 Z 的字符。</td></tr><tr><td style="text-align:left">[A-z]</td><td style="text-align:left">查找任何从大写 A 到小写 z 的字符。</td></tr><tr><td style="text-align:left">[xxx]</td><td style="text-align:left">查找给定集合内的任何字符。</td></tr><tr><td style="text-align:left">[^xxx]</td><td style="text-align:left">查找给定集合外的任何字符。</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td style="text-align:left">匹配出”\n”(换行符)之外的任何单个字符</td></tr><tr><td style="text-align:left">\w</td><td style="text-align:left">匹配包括下划线的任何<font color="red">字母,数字,下划线</font>字符,还可以使用[0-9a-zA-Z_]</td></tr><tr><td style="text-align:left">\W</td><td style="text-align:left">匹配任何非<font color="red">字母,数字,下划线</font>字符,还可以使用[^\w]</td></tr><tr><td style="text-align:left">\d</td><td style="text-align:left">匹配一个<font color="red">数字</font>字符,与使用[0-9]等价</td></tr><tr><td style="text-align:left">\D</td><td style="text-align:left">匹配一个<font color="red">非数字</font>字符,还可使用[^0-9]</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">匹配任何<font color="red">空白</font>字符</td></tr><tr><td style="text-align:left">\S</td><td style="text-align:left">匹配任何<font color="red">非空白</font>字符，还可使用[^\s]</td></tr><tr><td style="text-align:left">[\u4e00-\u9fa5]</td><td style="text-align:left">匹配<font color="red">中文</font>字符</td></tr><tr><td style="text-align:left">\n，\r，\f，\t，\v</td><td style="text-align:left">匹配换行符, 回车符, 换页符, 制表符, 垂直制表符</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配单词边界</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">匹配非单词边界</td></tr><tr><td style="text-align:left">\xxx</td><td style="text-align:left">查找以八进制数 xxx 规定的字符。</td></tr><tr><td style="text-align:left">\xdd</td><td style="text-align:left">查找以十六进制数 dd 规定的字符。</td></tr><tr><td style="text-align:left">\uxxxx</td><td style="text-align:left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式0次或多次 <font color="red">(0或1)</font></td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式1次或多次 <font color="red">(1或多)</font></td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式0次或1次  <font color="red">(0或1)</font></td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">匹配确定n次</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">至少匹配n次</td></tr><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">最少匹配n次，最多匹配m次</td></tr><tr><td style="text-align:left">^x</td><td style="text-align:left">匹配任何开头为x的字符串</td></tr><tr><td style="text-align:left">x$</td><td style="text-align:left">匹配任何结尾为x的字符串</td></tr></tbody></table><hr><h2 id="贪婪和惰性模式"><a href="#贪婪和惰性模式" class="headerlink" title="贪婪和惰性模式"></a>贪婪和惰性模式</h2><blockquote><p><strong>贪婪匹配：</strong>正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab.*c)。</p></blockquote><blockquote><p><strong>惰性匹配：</strong>就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab.*c)。</p></blockquote><p>贪婪模式的量词: <code>*</code>, <code>+</code>, <code>?</code>, <code>{n}</code>, <code>{n,}</code>, <code>{n,m}</code></p><p>惰性模式的量词: <code>*?</code>, <code>+?</code>, <code>??</code>, <code>{n}?</code>, <code>{n,}?</code>, <code>{n,m}?</code></p><hr><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>在正则表达式中用（）包起来的内容代表了一个分组，像这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;2&#125;)/</span></span><br><span class="line">reg.test(<span class="string">'12'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 这里reg中的(/d&#123;2&#125;)就表示一个分组，匹配两位数字</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>分组类型</strong></p></blockquote><ul><li>捕获型 ()</li><li>非捕获型 (?:)</li><li>正向前瞻性 (?=)</li><li>反向前瞻性 (?!)<br>我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串</li></ul><blockquote><p><strong>分组的应用</strong></p></blockquote><ul><li>捕获型与引用(<code>$1~$n</code>)<ul><li>被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">'2019-05-20'</span></span><br><span class="line">reg.test(dateStr) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">2</span> <span class="comment">// 05</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">3</span> <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">4</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><ul><li>反向引用(<code>\1~\n</code>)<ul><li>正则表达式里也能进行引用，这称为反向引用：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w&#123;3&#125;) is \1/</span></span><br><span class="line">reg.test(<span class="string">'kid is kig'</span>) <span class="comment">// true</span></span><br><span class="line">reg.test(<span class="string">'dik is dik'</span>) <span class="comment">// true</span></span><br><span class="line">reg.test(<span class="string">'kid is dik'</span>) <span class="comment">// fals</span></span><br><span class="line">reg.test(<span class="string">'dik is kid'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 如果引用越界或者不存在的编号，就被解析为普通的表达式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w&#123;3&#125;) is \6/</span></span><br><span class="line">reg.test(<span class="string">'kid is kid'</span>) <span class="comment">// false</span></span><br><span class="line">reg.test(<span class="string">'kid is \6'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>非捕获型分组<ul><li>使用分组并且不要捕获(即分组后不能是$1-$n去获取),使用<code>?:</code>,例如：</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="string">'2019-05-20'</span></span><br><span class="line">reg.test(date)</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// 05</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">2</span> <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><ul><li>正向前瞻性分组<ul><li>(?=patter),匹配字符后<code>紧跟patter</code>返回true,否则为false</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/kid is a (?=doubi)/</span></span><br><span class="line">reg.test(<span class="string">'kid is a doubi'</span>) <span class="comment">// true</span></span><br><span class="line">reg.test(<span class="string">'kid is a shabi'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>反向前瞻型分组<ul><li>(?!patter),匹配字符后<code>不紧跟patter</code>返回true,否则为false</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/kid is a (?!doubi)/</span></span><br><span class="line">reg.test(<span class="string">'kid is a doubi'</span>) <span class="comment">// false</span></span><br><span class="line">reg.test(<span class="string">'kid is a shabi'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>非捕获型和(正向前瞻,反向前瞻)区别<ul><li>非捕获型和(正向前瞻,反向前瞻)都不会捕获</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'kid is a doubi'</span></span><br><span class="line">reg = <span class="regexp">/(kid is a (?:doubi))/</span></span><br><span class="line">reg.test(str)</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span>  <span class="comment">// kid is a doubi</span></span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">/(kid is a (?=doubi))/</span></span><br><span class="line">reg = <span class="regexp">/(kid is a (?!doubi))/</span></span><br><span class="line">reg.test(str)</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// kid is a</span></span><br></pre></td></tr></table></figure><p>也就是说<code>非捕获型分组</code>匹配到的字符串任然会被<code>外层分组匹配到</code>，而<code>前瞻型不会</code>，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。</p><hr><h2 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h2><blockquote><p><strong>RegExp 对象方法</strong></p></blockquote><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">exec</td><td style="text-align:left">检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">检索字符串中指定的值。返回 true 或 false。</td></tr><tr><td style="text-align:left">toString</td><td style="text-align:left">返回正则表达式的字符串。</td></tr></tbody></table><blockquote><p><strong>正则表达式String对象的方法</strong></p></blockquote><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">search</td><td style="text-align:left">检索与正则表达式相匹配的值。</td></tr><tr><td style="text-align:left">match</td><td style="text-align:left">找到一个或多个正则表达式的匹配。</td></tr><tr><td style="text-align:left">replace</td><td style="text-align:left">替换与正则表达式匹配的子串。</td></tr><tr><td style="text-align:left">split</td><td style="text-align:left">把字符串分割为字符串数组。</td></tr></tbody></table><blockquote><p><strong>RegExp 对象属性</strong></p></blockquote><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">constructor</td><td style="text-align:left">返回一个函数，该函数是一个创建 RegExp 对象的原型。</td></tr><tr><td style="text-align:left">global</td><td style="text-align:left">判断是否设置了 “g” 修饰符</td></tr><tr><td style="text-align:left">ignoreCase</td><td style="text-align:left">判断是否设置了 “i” 修饰符</td></tr><tr><td style="text-align:left">multiline</td><td style="text-align:left">判断是否设置了 “m” 修饰符</td></tr><tr><td style="text-align:left">source</td><td style="text-align:left">返回正则表达式的匹配模式</td></tr><tr><td style="text-align:left">lastIndex</td><td style="text-align:left">用于规定下次匹配的起始位置</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例子：source</span><br><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/ani/g</span></span><br><span class="line">patt.test(<span class="string">'This is a ani'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(patt.source) <span class="comment">// ani</span></span><br><span class="line"></span><br><span class="line">例子：lastIndex</span><br><span class="line"><span class="keyword">var</span> patt = <span class="regexp">/ani/g</span></span><br><span class="line"><span class="built_in">console</span>.log(patt.lastIndex) <span class="comment">// 0</span></span><br><span class="line">patt.test(<span class="string">'This is a ani'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(patt.lastIndex) <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为当前的lastIndex(匹配其实位置为13,所以从第13位开始查找,匹配不到默认重置为0)</span></span><br><span class="line">patt.test(<span class="string">'This is a ani'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(patt.lastIndex) <span class="comment">// 0</span></span><br><span class="line">patt.test(<span class="string">'This is is is is is a ani'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">在匹配前重置lastIndex: patt.lastIndex = <span class="number">0</span></span><br><span class="line">                      patt.test(<span class="string">'This is a ani'</span>) <span class="comment">// true</span></span><br><span class="line">不要使用定义的变量缓存正则表达式： /ani/g.test(<span class="string">'This is a ani'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语
      
    
    </summary>
    
      <category term="javascript基础" scheme="http://yoursite.com/categories/javascript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="http://yoursite.com/2019/05/20/%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8-Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/05/20/文档使用-Git常用命令/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-23T08:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><blockquote><p><strong>Git主要包含三个区</strong></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/memory1994/SaveImage/master/git_three_rigon.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>工作区(working diretory) 用于修改文件</li><li>缓存区(stage) 是用来暂时存放工作区中修改的内容</li><li>提交历史（commit history） 提交代码的历史记录</li></ul><hr><h2 id="git一般配置"><a href="#git一般配置" class="headerlink" title="git一般配置"></a>git一般配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git --version <span class="comment">// 查看git版本</span></span><br><span class="line">git config --global user.name <span class="comment">// 获取当前登录的用户名</span></span><br><span class="line">git config --global user.email <span class="comment">// 获取当前登录用户的邮箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果刚没有获取到用户配置，则只能拉取代码，不能修改  要是使用git，你要告诉git是谁在使用</span></span><br><span class="line">git config --global user.name <span class="string">'userName'</span>  <span class="comment">// 设置git账户，userName为你的git账号</span></span><br><span class="line">git config --global user.email <span class="string">'email'</span></span><br></pre></td></tr></table></figure><p><strong>1.初始化git仓库</strong></p><ul><li><code>git init</code>：在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹.</li></ul><p><strong>2.创建忽略文件</strong></p><ul><li><code>touch .gitignore</code>：不需要服务器端提交的内容可以写到忽略文件里</li></ul><p><strong>3.克隆远程代码</strong></p><ul><li><code>git clone [url]</code>：获取一个url对应的远程Git repo, 创建一个local copy.</li></ul><p><strong>4.拉取代码</strong></p><ul><li><code>git pull</code></li></ul><p><strong>5.推送至远程代码</strong></p><ul><li><code>git push</code></li></ul><hr><h2 id="git新建-切换分支-branch-checkout"><a href="#git新建-切换分支-branch-checkout" class="headerlink" title="git新建,切换分支(branch,checkout)"></a>git新建,切换分支(branch,checkout)</h2><blockquote><p><strong>git branch</strong></p></blockquote><ul><li><code>git branch</code>：查看所有本地分支</li><li><code>git branch -r</code>：查看所有远程分支</li><li><code>git branch -a</code>：查看所有本地，远程分支</li><li><code>git branch dev</code>：新建本地dev分支，不切换当前分支</li><li><code>git branch -m dev version</code>：修改本地分支dev名称为version</li></ul><blockquote><p><strong>git checkout</strong></p></blockquote><ul><li><code>git checkout dev</code>：切换分支到dev</li><li><code>git checkout -b dev</code>：新建dev分支，并切换当前分支到dev分支</li><li><code>git checkout .</code>：把当前分支没有暂存的所有修改文件，恢复成未修改是的样子</li></ul><blockquote><p><strong>新增本地分支推送到远程流程</strong></p></blockquote><ul><li><code>git branch dev</code> || <code>git checkout -b dev</code>：新增dev分支</li><li><code>git push --set-upstream origin dev</code> || <code>git push -u origin dev</code>：建立本地到远端仓的链接(建立链接后，以后提交远端直接git push即可)</li></ul><blockquote><p><strong>删除本地和远程分支</strong></p></blockquote><ul><li><code>git branch -d(--delete) dev</code>：删除本地dev分支</li><li><code>git push origin --delete dev</code> || <code>git push origin :dev</code>：删除远程dev分支</li></ul><hr><h2 id="git暂存区-add"><a href="#git暂存区-add" class="headerlink" title="git暂存区(add)"></a>git暂存区(add)</h2><ul><li><code>git add *</code>：提交所有变化,包括文件修改(modified)以及新文件(new),但不包括被删除的文件</li><li><code>git add -u</code>(–update)：提交被修改(modified)和被删除(deleted)文件,不包括新文件(new)</li><li><code>git add .</code>, <code>git add -A</code>(–all)：提交新文件和被修改文件,被删除文件</li></ul><hr><h2 id="git提交本地-commit"><a href="#git提交本地-commit" class="headerlink" title="git提交本地(commit)"></a>git提交本地(commit)</h2><ul><li><code>git commit -m &#39;message&#39;</code>：提交已经过git add的文件到本地版本库</li><li><code>git commit -a -m &#39;message&#39;</code>：提交进过git add和没有进过git add的文件到本地版本库</li><li><code>git commit --amend -m &#39;message&#39;</code>：不新增commit提交记录，覆盖上一次提交记录</li></ul><h2 id="git回滚代码-reset-revert"><a href="#git回滚代码-reset-revert" class="headerlink" title="git回滚代码(reset,revert)"></a>git回滚代码(reset,revert)</h2><blockquote><p><strong>reset(版本回撤)</strong></p></blockquote><p>reset 会重置并删除回撤的提交历史记录</p><ul><li><code>git reset --soft</code>：回退版本库,到<code>暂存区</code></li><li><code>git reset --mixed</code>：回退版本库，暂存区,到<code>工作区</code>。(–mixed为git reset的默认参数，即当任何参数都不加的时候的参数)</li><li><code>git reset --hard</code>：回退版本库，暂存区，工作区。（因此我们修改过的代码就没了，需要谨慎使用）</li><li><code>git reset HEAD(head)~1</code> || <code>git reset commit_id</code>：使用head~n回滚到第n次提交，或者commit_id</li></ul><blockquote><p><strong>revert(撤销操作)</strong></p></blockquote><p>revert 不会重置提交的历史记录，会创建一个新的提交。</p><ul><li><code>git revert HEAD(head)~1</code> || <code>git revert commit_id</code>：使用head~n回滚到第n次提交，或者commit_id</li><li><code>git revert --continue</code></li><li><code>git revert --abort</code>：如果不想解决冲突的话可以取消撤回</li><li><code>git revert --quit</code></li></ul><h2 id="git代码合并-merge-rebase"><a href="#git代码合并-merge-rebase" class="headerlink" title="git代码合并(merge,rebase)"></a>git代码合并(merge,rebase)</h2><blockquote><p><strong>merge合并策略</strong></p></blockquote><ul><li><code>git merge [-s 合并策略] [-x 合并策略参数] &lt;commit&gt;...</code><ul><li>resolve(合并策略)：只能用于两个分支的合并，这个合并策略被认为是最安全、最快的合并策略</li><li>recursive(合并策略)：只能用于两个分支的合并，两个分支的合并默认使用该策略。该策略可以使用选项：<ul><li>ours(合并策略参数)：在遇到冲突的时候，选择当前分支的版本，而忽略远程合并过来的版本。</li><li>theirs(合并策略参数)：和ours选项相反</li><li>subtree<a href="合并策略参数">=path</a>：使用子树合并策略</li></ul></li><li>octpus(合并策略)：用于合并两个以上分支的策略，该策略拒绝执行需要手动解决的复杂合并。<ul><li>ours(合并策略参数)：可以用于任意多个分支的合并策略，合并的结果总是使用当前分支的内容而丢弃远程合并过来的版本内容</li><li>subtree(合并策略参数)：这是一个经过调整后的recursive策略</li></ul></li></ul></li></ul><p>例子如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前分支合并dev分支，有冲突完全接受dev分支的代码</span></span><br><span class="line">git merge -s recursive -x theirs dev</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>rebase</strong></p></blockquote><ul><li><code>git rebase</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git-常用命令&quot;&gt;&lt;a href=&quot;#Git-常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git 常用命令&quot;&gt;&lt;/a&gt;Git 常用命令&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Git主要包含三个区&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="文档使用" scheme="http://yoursite.com/categories/%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Git常用命令" scheme="http://yoursite.com/tags/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>markdowm使用文档</title>
    <link href="http://yoursite.com/2019/05/11/%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8-markdowm%E6%96%87%E6%A1%A3/"/>
    <id>http://yoursite.com/2019/05/11/文档使用-markdowm文档/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-20T03:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p><p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p><ul><li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li><li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="noopener">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="noopener">离线Chrome App</a>，支持移动端 Web；</li><li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li></ul><hr><p>[TOC]</p><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="noopener">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Cmd + /</code>查看帮助。 </p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:right">Value</th><th style="text-align:center">Qty</th></tr></thead><tbody><tr><td style="text-align:left">Computer</td><td style="text-align:right">1600 USD</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Phone</td><td style="text-align:right">12 USD</td><td style="text-align:center">12</td></tr><tr><td style="text-align:left">Pipe</td><td style="text-align:right">1 USD</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>以及时序图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><blockquote><p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">语法</a>。</p></blockquote><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p><ul><li style="list-style: none"><input type="checkbox" checked> 已完成事项</li><li style="list-style: none"><input type="checkbox"> 待办事项1</li><li style="list-style: none"><input type="checkbox"> 待办事项2</li></ul><blockquote><p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p></blockquote><h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p><h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p><h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p><blockquote><p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p></blockquote><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p><blockquote><p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p></blockquote><h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p></blockquote><h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Cmd + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Cmd + /</code><br>同步文档    <code>Cmd + S</code><br>创建文档    <code>Cmd + Opt + N</code><br>最大化编辑器    <code>Cmd + Enter</code><br>预览文档 <code>Cmd + Opt + Enter</code><br>文档管理    <code>Cmd + O</code><br>系统菜单    <code>Cmd + M</code> </p><p>加粗    <code>Cmd + B</code><br>插入图片    <code>Cmd + G</code><br>插入链接    <code>Cmd + L</code><br>提升标题    <code>Cmd + H</code></p><h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p><h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul><li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="noopener">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="noopener">@GGock</a></li><li>邮箱：<a href="mailto:&#x68;&#117;&#x73;&#116;&#x67;&#111;&#x63;&#x6b;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;" target="_blank" rel="noopener">&#x68;&#117;&#x73;&#116;&#x67;&#111;&#x63;&#x6b;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></li></ul><hr><p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p><p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="noopener">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="noopener">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欢迎使用马克飞象&quot;&gt;&lt;a href=&quot;#欢迎使用马克飞象&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用马克飞象&quot;&gt;&lt;/a&gt;欢迎使用马克飞象&lt;/h1&gt;&lt;p&gt;@(示例笔记本)[马克飞象|帮助|Markdown]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;马克飞象
      
    
    </summary>
    
      <category term="文档使用" scheme="http://yoursite.com/categories/%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="markdowm" scheme="http://yoursite.com/tags/markdowm/"/>
    
  </entry>
  
  <entry>
    <title>css基础</title>
    <link href="http://yoursite.com/2018/04/30/%E9%9D%A2%E8%AF%95-css/"/>
    <id>http://yoursite.com/2018/04/30/面试-css/</id>
    <published>2018-04-29T16:00:00.000Z</published>
    <updated>2019-05-20T03:34:44.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端面试题" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="css面试题" scheme="http://yoursite.com/tags/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>web安全类</title>
    <link href="http://yoursite.com/2018/04/30/%E9%9D%A2%E8%AF%95-web%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2018/04/30/面试-web安全/</id>
    <published>2018-04-29T16:00:00.000Z</published>
    <updated>2019-05-16T01:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><p>XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p><p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p><hr><blockquote><big>XSS分类</big></blockquote><p>根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击：</p><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p><blockquote><big>反射型XSS的攻击步骤：</big></blockquote><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><blockquote><big>如何防范反射型XSS攻击</big></blockquote><p><strong>对字符串进行编码。</strong></p><p>对url的查询参数进行转义后再输出到页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/welcome'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><p>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText</code>、<code>.textContent</code>、<code>.setAttribute()</code> 等。</p><blockquote><big>DOM 型 XSS 的攻击步骤：</big></blockquote><p>1.攻击者构造出特殊数据，其中包含恶意代码。<br>2.用户浏览器执行了恶意代码。<br>3.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p><blockquote><big>如何防范 DOM 型 XSS 攻击</big></blockquote><p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。</p><p>1.对于<code>url</code>链接(例如图片的<code>src</code>属性)，那么直接使用 <code>encodeURIComponent</code> 来转义。</p><p>2.非<code>url</code>，我们可以这样进行编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;apos;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。</p><blockquote><big>存储型 XSS 的攻击步骤：</big></blockquote><p>1.攻击者将恶意代码提交到目标网站的数据库中。<br>2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</p><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><blockquote><big>如何防范存储型XSS攻击：</big></blockquote><p>1.前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)<br>2.服务器接收到数据，在存储到数据库之前，进行转义/过滤<br>3.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</p><h2 id="XSS其他防范手段"><a href="#XSS其他防范手段" class="headerlink" title="XSS其他防范手段"></a>XSS其他防范手段</h2><p><strong>1.Content Security Policy</strong></p><ul><li>在服务端使用 HTTP的 <code>Content-Security-Policy</code> 头部来指定策略，或者在前端设置 <code>meta</code> 标签。</li></ul><p>例如下面的配置只允许加载同域下的资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"form-action 'self';"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端和服务端设置 CSP 的效果相同，但是meta无法使用report</p><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><p>1.禁止加载外域代码，防止复杂的攻击逻辑。<br>2.禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。<br>3.禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。<br>4.禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。<br>5.合理使用上报可以及时发现 XSS，利于尽快修复问题。</p><p><strong>2.输入内容长度控制</strong></p><ul><li>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</li></ul><p><strong>3.输入内容限制</strong></p><ul><li>对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。</li></ul><p><strong>4.其他安全措施</strong></p><ul><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h2 id="XSS检测"><a href="#XSS检测" class="headerlink" title="XSS检测"></a>XSS检测</h2><p><strong>1.使用通用 XSS 攻击字串手动检测 XSS 漏洞</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如: javascript:/*-/*`/*\`/*&apos;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</span><br></pre></td></tr></table></figure><p>能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.使用第三方工具进行扫描</strong></p><hr><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><blockquote><big>典型的CSRF攻击流程：</big></blockquote><p>1.受害者登录A站点，并保留了登录凭证（Cookie）。<br>2.攻击者诱导受害者访问了站点B。<br>3.站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。<br>4.站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。<br>5.站点A以受害者的名义执行了站点B的请求。<br>6.攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/memory1994/SaveImage/master/csrf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><big>CSRF的特点</big></blockquote><p>1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。<br>2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)<br>3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</p><blockquote><big>CSRF 攻击防御</big></blockquote><ol><li><p><strong>添加验证码(体验不好)</strong><br>验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</p></li><li><p><strong>判断请求的来源：检测Referer(并不安全，Referer可以被更改)</strong><br><code>Referer</code> 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 <code>Referer</code> 本身是可以被修改的，因为不能仅依赖于  <code>Referer</code></p></li><li><p><strong>使用Token(主流)</strong><br>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。</p></li></ol><ul><li>服务端给用户生成一个token，加密后传递给用户</li><li>用户在提交请求时，需要携带这个token</li><li>服务端验证token是否正确</li></ul><ol start="4"><li><strong>Samesite Cookie属性</strong><br>为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax。<br>部署简单，并能有效防御CSRF攻击，但是存在兼容性问题。<br>Samesite=Strict<br><code>Samesite=Strict</code> 被称为是严格模式,表明这个 Cookie 在任何情况都不可能作为第三方的 Cookie，有能力阻止所有CSRF攻击。此时，我们在B站点下发起对A站点的任何请求，A站点的 Cookie 都不会包含在cookie请求头中。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**Samesite=Lax**</span><br><span class="line">`Samesite=Lax` 被称为是宽松模式，与 Strict 相比，放宽了限制，允许发送安全 HTTP 方法带上 Cookie，如 `Get` / `OPTIONS` 、`HEAD` 请求.</span><br><span class="line">但是不安全 HTTP 方法，如： `POST`, `PUT`, `DELETE` 请求时，不能作为第三方链接的 Cookie</span><br></pre></td></tr></table></figure><p>为了更好的防御CSRF攻击，我们可以组合使用以上防御手段。</p><hr><h1 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h1><p>点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。</p><h2 id="典型点击劫持攻击流程"><a href="#典型点击劫持攻击流程" class="headerlink" title="典型点击劫持攻击流程"></a>典型点击劫持攻击流程</h2><p>1.攻击者构建了一个非常有吸引力的网页【不知道哪些内容对你们来说有吸引力，我就不写页面了，偷个懒】<br>2.将被攻击的页面放置在当前页面的 <code>iframe</code> 中<br>3.使用样式将 iframe 叠加到非常有吸引力内容的上方<br>4.将iframe设置为100%透明<br>5.你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。</p><h2 id="点击劫持防御"><a href="#点击劫持防御" class="headerlink" title="点击劫持防御"></a>点击劫持防御</h2><p>1.<strong>frame busting</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( top.location != <span class="built_in">window</span>.location )&#123;</span><br><span class="line">    top.location = <span class="built_in">window</span>.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是: HTML5中iframe的 <code>sandbox</code> 属性、IE中iframe的<code>security</code> 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。</p><ol start="2"><li><strong>X-Frame-Options</strong></li></ol><p>X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。</p><p>可以设置为以下值:</p><ul><li>DENY: 拒绝任何域加载</li><li>SAMEORIGIN: 允许同源域下加载</li><li>ALLOW-FROM: 可以定义允许frame加载的页面地址</li></ul><h2 id="安全扫描工具"><a href="#安全扫描工具" class="headerlink" title="安全扫描工具"></a>安全扫描工具</h2><p>1.<strong><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FArachni%2Farachni" target="_blank" rel="noopener">Arachni</a></strong></p><p>Arachni是基于Ruby的开源，功能全面，高性能的漏洞扫描框架，Arachni提供简单快捷的扫描方式，只需要输入目标网站的网址即可开始扫描。它可以通过分析在扫描过程中获得的信息，来评估漏洞识别的准确性和避免误判。<br>Arachni默认集成大量的检测工具，可以实施 代码注入、CSRF、文件包含检测、SQL注入、命令行注入、路径遍历等各种攻击。<br>同时，它还提供了各种插件，可以实现表单爆破、HTTP爆破、防火墙探测等功能。<br>针对大型网站，该工具支持会话保持、浏览器集群、快照等功能，帮助用户更好实施渗透测试</p><p>2.<strong><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fmozilla%2Fhttp-observatory%2F" target="_blank" rel="noopener">Mozilla HTTP Observatory</a></strong></p><p>Mozilla HTTP Observatory，是Mozilla最近发布的一款名为Observatory的网站安全分析工具，意在鼓励开发者和系统管理员增强自己网站的安全配置。用法非常简单：输入网站URL，即可访问并分析网站HTTP标头，随后可针对网站安全性提供数字形式的分数和字母代表的安全级别。</p><ul><li>Cookie</li><li>跨源资源共享（CORS）</li><li>内容安全策略（CSP）</li><li>HTTP公钥固定（Public Key Pinning）</li><li>HTTP严格安全传输（HSTS）状态</li><li>是否存在HTTP到HTTPs的自动重定向</li><li>子资源完整性（Subresource Integrity）</li><li>X-Frame-Options</li><li>X-XSS-Protection</li></ul><p>3.<strong><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fandresriancho%2Fw3af" target="_blank" rel="noopener"> w3af</a></strong></p><p>W3af是一个基于Python的Web应用安全扫描器。可帮助开发人员，有助于开发人员和测试人员识别Web应用程序中的漏洞。<br>扫描器能够识别200多个漏洞，包括跨站点脚本、SQL注入和操作系统命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h1&gt;&lt;p&gt;XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，
      
    
    </summary>
    
      <category term="前端面试题" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="web其他" scheme="http://yoursite.com/tags/web%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
